<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="咸鱼">
    <meta name="author" content="9unk">
    
    <title>
        
            8086汇编-高级汇编语言技术 |
        
        9unk Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/logo.jpg","favicon":"/images/logo.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"人初做事，如鸡伏卵，不舍而生气渐充。如燕营巢，不息而结构渐牢。如滋培之木，不见其长，有时而大。如有本之泉，不舍昼夜，盈科而后进，放乎四海。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                9unk Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">8086汇编-高级汇编语言技术</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/logo.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">9unk</span>
                        
                            <span class="author-label">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-10-18 21:53:00</span>
        <span class="mobile">2022-10-18 21:53</span>
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>11.6k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>46 分钟</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="结构和记录"><a href="#结构和记录" class="headerlink" title="结构和记录"></a>结构和记录</h1><p>为了使程序员能更方便、更有效地对数据进行组织和描述，宏汇编语言除了提供定义简单数据变量地伪指令（如DB和DW等）外，还提供了用于说明复杂数据类型地伪指令，利用这些伪指令能够说明复杂的数据类型，从而定义复杂的数据变量。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="结构类型的说明"><a href="#结构类型的说明" class="headerlink" title="结构类型的说明"></a>结构类型的说明</h3><p>在描述结构型数据或使用架构型变量之前，需要说明结构类型。用伪指令 STRUC 和 ENDS 把一系列数据定义语句包括起来就说明了一个结构体类型，一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构名 STRUC</span><br><span class="line">       数据定义语句序列</span><br><span class="line">结构名 ENDS</span><br></pre></td></tr></table></figure>
<p>案例：一个名为 PERSON 的结构类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PERSON STRUC</span><br><span class="line">ID  dw ?</span><br><span class="line">SCORE   db 0</span><br><span class="line">PNAME   db &#x27;ABCDEFGH&#x27;</span><br><span class="line">PERSON ENDS</span><br></pre></td></tr></table></figure>

<ol>
<li>组成结构的变量称为结构的字段，相应的变量称为字段名。</li>
<li>一个结构中可以含有任意数目的字段，并且各字段可以有不同的长度（基本单位是字节），还可以独立地存取。结构中的字段也可以没有字段名。</li>
<li>结构中的字段名代表了从结构的开始到相应字段的偏移。在说明结构体类型时，可以给字段赋初值，也可以不赋初值。</li>
<li>如果字段是一个字符串，那么确保其初始值有足够的长度以适应可能最长的字符串。</li>
</ol>
<p>如下面的 MESST 的结构类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MESST STRUC</span><br><span class="line">MBUFF DB 100 DUP(?)</span><br><span class="line">CRLF DB 0DH,0AH</span><br><span class="line">ENDMARK DB 24H</span><br><span class="line">MESST ENDS</span><br></pre></td></tr></table></figure>
<p>结构 MESST 中的字段 MBUFF 和 CRLF 均含有多个值。</p>
<blockquote>
<p>在说明结构类型时，结构名必须是唯一的，各字段名也应该是唯一的。在说明结构类型时不进行任何存储分配，只有在定义结构变量时才进行存储分配。</p>
</blockquote>
<p>注：标记一个结构类型结束的伪指令与标记一个段结束的伪指令用相同的助记符 ENDS，汇编程序通过上下文理解 ENDS 的含义，所以要确保每一个 SEGMENT 伪指令和每一个 STRUC 伪指令有各自对应的 ENDS 伪指令。</p>
<h3 id="结构变量的定义"><a href="#结构变量的定义" class="headerlink" title="结构变量的定义"></a>结构变量的定义</h3><p>在说明了结构类型后，就可以定义相应的结构变量。结构变量定义的一般格式如下：</p>
<blockquote>
<p>[变量名] 结构名 &lt;[字段值表]&gt;</p>
</blockquote>
<ol>
<li>变量名就是当前定义的结构变量的名称，结构变量名也可以省略。如果省略，那么就不能直接通过符号名访问该结构变量。</li>
<li>结构名是在说明结构类型时所用的名字。</li>
<li>字段值表用来给结构变量的各字段赋初始值，其中各字段值的排列顺序及类型应与结构定义时的各字段相一致，中间以逗号分隔。</li>
<li>如果某个字段采用在说明结构时所给定的缺省初值，那么可简单地用逗号表示；如果结构变量的所有字段均如此，那么可省去字段值表，但仍必须保留一对尖括号。</li>
</ol>
<p>例如，设上述结构 PERSON，那么可定义如下结构变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STUDENT1 PERSON &lt;103,88,&#x27;WANG&#x27;&gt;    ;三个字段都重赋值</span><br><span class="line">STUDENT2 PERSON &lt;104,,&#x27;LIMING&#x27;&gt;    ;字段 SCORE 仍用缺省初值</span><br><span class="line">STUDENT  PERSON &lt;&gt;                 ;三个字段均用缺省初值</span><br><span class="line">         PERSON 99 dup (&lt;&gt;)        ;定义99各结构变量，初值不变</span><br></pre></td></tr></table></figure>
<p>对宏汇编程序 MASM 而言，如果某个字段有多个值，那么在定义结构变量时，就不能给该字段赋初始值。如上面说明地结构 MESST，不饿能给 MBUFF 字段和CRLF字段重赋初值。<br>下面定义结构变量的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MESS1 MESST &lt;&gt;</span><br><span class="line">MESS2 MESST &lt;,,0&gt;</span><br></pre></td></tr></table></figure>

<h3 id="结构变量及其字段的访问"><a href="#结构变量及其字段的访问" class="headerlink" title="结构变量及其字段的访问"></a>结构变量及其字段的访问</h3><p>通过结构变量名可直接存取结构变量。若要存取结构变量中的某一字段，则可采用如下形式：</p>
<blockquote>
<p>结构变量名.结构字段名</p>
</blockquote>
<p>结构变量与结构字段名中间用点号分隔，并且结构字段名所代表的字段必须是对应结构所具有的字段。这种形式表示的变量的地址偏移值是结构变量地址（起始地址）的偏移值与相应字段偏移值之和。</p>
<p>案例：演示结构变量的直接寻址和变址寻址（相对基址）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-1.asm</span><br><span class="line">;功能：演示结构变量的直接寻址和变址寻址（相对基址）</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">DATE STRUC</span><br><span class="line">YEAR DW ?</span><br><span class="line">MONTH DB ?</span><br><span class="line">DAY DB ?</span><br><span class="line">DATE ENDS</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">YESTERDAY DATE &lt;1995,7,17&gt;</span><br><span class="line">TODAY DATE &lt;1995,7,18&gt;</span><br><span class="line">TOMORROW DATE &lt;1995,7,19&gt;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;直接寻址</span><br><span class="line">    mov AL,YESTERDAY.DAY</span><br><span class="line">    mov ah,TODAY.MONTH</span><br><span class="line">    mov TOMORROW.YEAR,dx</span><br><span class="line">    ;变址寻址</span><br><span class="line">    mov bx,offset YESTERDAY</span><br><span class="line">    mov al,[bx].MONTH</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196489714-af24b7ab-3383-4677-8963-7ca4ce403424.png"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196490771-cd78b035-b717-48c0-ac5a-2f032e45ce45.png"
                      alt="2"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196491478-25a87df3-7d1e-473a-871b-7b6da637af23.png"
                      alt="3"
                ></p>
<p>例1：数据文件 SCORE.DAT 中一次存放着30个学生的成绩记录，文件（成绩）记录具有如下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学号        整数    2字节</span><br><span class="line">姓名        字符串  8字节</span><br><span class="line">语文成绩    整数    1字节</span><br><span class="line">数学成绩    整数    1字节</span><br><span class="line">外语成绩    整数    1字节</span><br></pre></td></tr></table></figure>
<p>写一个程序计算三门课程的总分，把学号和总分依次写到文件 SCORE.SUM 中。SCORE.SUM 文件记录两个字段，第一个字段是学号，第二个字段是总分（用2字节表示）。<br>实现流程是：</p>
<ol>
<li>打开文件 SCORE.DAT;</li>
<li>循环处理每个学生的成绩，把学号和总分放到缓冲区中；</li>
<li>关闭文件 SCORE.DAT</li>
<li>新建文件 SCORE.SUM</li>
<li>把缓冲区的内容写入文件 SCORE.SUM</li>
<li>关闭文件 SCORE.SUM</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-2.asm</span><br><span class="line">;功能：写一个程序计算三门课程的总分，把学号和总分依次写到文件 SCORE.SUM 中。SCORE.SUM 文件记录两个字段，第一个字段是学号，第二个字段是总分（用2字节表示）。</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">;定义常量</span><br><span class="line">COUTN = 30</span><br><span class="line"></span><br><span class="line">;原始成绩结构体 SCORE</span><br><span class="line">SCORE STRUC</span><br><span class="line">IDS dw ?             ;学号</span><br><span class="line">SNAME db 8 dup (&#x27; &#x27;)    ;姓名</span><br><span class="line">LANG db 0           ;语文成绩</span><br><span class="line">MATH db 0           ;数学成绩</span><br><span class="line">ENG  db 0           ;英语成绩</span><br><span class="line">SCORE ENDS</span><br><span class="line"></span><br><span class="line">;对应学号、姓名和总分的 ITEM 的定义</span><br><span class="line">ITEM STRUC</span><br><span class="line">IDD  dw ?            ;学号</span><br><span class="line">SUM dw 0            ;总分，总分300会超过1字节空间。</span><br><span class="line">ITEM ENDS</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">BUFFER SCORE &lt;&gt;              ;存放原始成绩的缓冲区</span><br><span class="line">STABLE ITEM COUTN dup (&lt;&gt;)   ;预留存储总表的缓冲区</span><br><span class="line">FNAME1 db &#x27;SCORE.DAT&#x27;,0     ;原始文件名</span><br><span class="line">FNAME2 db &#x27;SCORE.SUM&#x27;,0     ;存储新的数据文件名</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,offset STABLE    ;STABLE 需要变址寄存器存储数据</span><br><span class="line">    ;打开文件 SCORE.DAT</span><br><span class="line">    mov dx,offset FNAME1</span><br><span class="line">    mov ax,3d00h</span><br><span class="line">    int 21h                 ;以只读方式打开 SCORE.DAT</span><br><span class="line">    jc stop                 ;文件打开失败，终止程序</span><br><span class="line"></span><br><span class="line">    ;一次性读13个字节，初始化各寄存器</span><br><span class="line">    mov bx,ax</span><br><span class="line">    mov cx,13</span><br><span class="line">    mov dx,offset BUFFER</span><br><span class="line">READ:</span><br><span class="line">    mov ah,3fh</span><br><span class="line">    int 21h</span><br><span class="line">    ;判断有没有读取到字符，没有读到就说明已经读到文件尾了。</span><br><span class="line">    cmp ax,cx</span><br><span class="line">    jnz clsf1</span><br><span class="line">    ;将结果存储到 STABLE 中</span><br><span class="line">    mov ax,BUFFER.IDS</span><br><span class="line">    mov [si],ax</span><br><span class="line">    xor ax,ax</span><br><span class="line">    mov al,BUFFER.LANG</span><br><span class="line">    add al,BUFFER.MATH</span><br><span class="line">    add al,BUFFER.ENG</span><br><span class="line">    adc ah,0</span><br><span class="line">    add si,TYPE STABLE.IDD</span><br><span class="line">    mov [si],ax</span><br><span class="line">    ;</span><br><span class="line">    add si,TYPE STABLE.SUM</span><br><span class="line">    jmp READ</span><br><span class="line">clsf1:                      ;关闭文件 SCORE.DAT</span><br><span class="line">    mov ah,3eh</span><br><span class="line">    int 21h</span><br><span class="line">    cmp word ptr STABLE,0</span><br><span class="line">    jz stop                 ;如果缓冲区中未读取任何数据，结束程序</span><br><span class="line">    ;新建 SCORE.SUM</span><br><span class="line">    mov dx,offset FNAME2</span><br><span class="line">    mov cx,0</span><br><span class="line">    mov ax,3c00h</span><br><span class="line">    int 21h</span><br><span class="line">    ;写数据需要变址寄存器</span><br><span class="line">    mov si,offset STABLE</span><br><span class="line">    ;写数据</span><br><span class="line">    mov bx,ax</span><br><span class="line">    mov cx,4</span><br><span class="line">WRITE:</span><br><span class="line">    ;判断有没有写到缓冲区的最后一个字符</span><br><span class="line">    cmp word ptr [si],0</span><br><span class="line">    jz clsf2</span><br><span class="line">    mov dx,si</span><br><span class="line">    mov ah,40h</span><br><span class="line">    int 21h</span><br><span class="line">    add si,TYPE ITEM</span><br><span class="line">    jmp WRITE</span><br><span class="line">clsf2:</span><br><span class="line">    mov ah,3eh</span><br><span class="line">    int 21h</span><br><span class="line">stop:</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196846127-25b77ca1-43bc-4c9e-acfb-e8bd089f8d00.png"
                      alt="4"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196861012-99b4cf16-344a-49f7-822e-b1d7355ff1b9.png"
                      alt="5"
                ></p>
<p>在程序 T7-2.asm 中，定义了两个结构 SCORE 和 ITEM，用来描述文件记录的字段组成。利用 SCORE 定义了存放原始成绩记录的缓冲区。利用 ITEM 定义了一张总表，然后借助指向总分表当前项的指针访问当前的学号和总分字段。此外还利用了 TYPE 得到结构的字节数。</p>
<p>例2：写一个求字符串长度的子程序。子程序调用过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-3.asm</span><br><span class="line">;功能：写一个求字符串长度的子程序。子程序调用过程如下：</span><br><span class="line">;子程序名：STRLEN</span><br><span class="line">;功   能：检测字符串长度</span><br><span class="line">;入口参数：字符串首地址的段值和偏移在堆栈顶</span><br><span class="line">;出口参数：AX=字符串长度</span><br><span class="line">;说明：（1）字符串以0结尾；字符串长度不包括结尾标志。</span><br><span class="line">;     （2）本过程是一个远过程</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">;堆栈结构体 PARM</span><br><span class="line">PARM STRUC</span><br><span class="line">BPREG DW ?      ;对应 bp 寄存器保存单元</span><br><span class="line">RETADR DD ?     ;对应返回地址</span><br><span class="line">STROFF DW ?     ;对应入口参数中的偏移</span><br><span class="line">STRSEG DW ?     ;对应入口参数中的段值</span><br><span class="line">PARM ENDS</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">string1 db &#x27;Hello World!&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,seg string1</span><br><span class="line">    push ax</span><br><span class="line">    mov ax,offset string1</span><br><span class="line">    push ax</span><br><span class="line">    call far ptr STRLEN</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">;-------------------------------------------------------</span><br><span class="line">;子程序名：STRLEN</span><br><span class="line">;功   能：检测字符串长度</span><br><span class="line">;入口参数：字符串首地址的段值和偏移在堆栈顶</span><br><span class="line">;出口参数：AX=字符串长度</span><br><span class="line">;说明：（1）字符串以0结尾；字符串长度不包括结尾标志。</span><br><span class="line">;      （2）本过程是一个远过程</span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">STRLEN PROC FAR</span><br><span class="line">    PUSH BP</span><br><span class="line">    MOV BP,SP</span><br><span class="line">    PUSH DS</span><br><span class="line">    PUSH SI</span><br><span class="line">    MOV DS,[BP].STRSEG  ;取字符串首地址的段值</span><br><span class="line">    MOV SI,[BP].STROFF  ;取字符串首地址的偏移</span><br><span class="line">    XOR AL,AL</span><br><span class="line">STRLEN1:</span><br><span class="line">    CMP BYTE PTR [SI],AL</span><br><span class="line">    JZ STRLEN2</span><br><span class="line">    INC SI</span><br><span class="line">    JMP STRLEN1</span><br><span class="line">STRLEN2:</span><br><span class="line">    MOV AX,SI</span><br><span class="line">    SUB AX,[BP].STROFF</span><br><span class="line">    POP SI</span><br><span class="line">    POP DS</span><br><span class="line">    POP BP</span><br><span class="line">    RET</span><br><span class="line">STRLEN  ENDP</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196892613-a4a84f81-4b88-45c0-8704-72357c45f5c9.png"
                      alt="7"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196879862-aedc0c11-6c21-4386-ae55-6065dd0f19d8.png"
                      alt="6"
                ></p>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>记录类型为按二进制位存取数据或信息提供了方便。</p>
<h3 id="记录类型的说明"><a href="#记录类型的说明" class="headerlink" title="记录类型的说明"></a>记录类型的说明</h3><p>在描述记录型数据或使用记录型变量之前，需要说明记录类型。伪指令 RECORD 用于说明记录类型，一般格式如下：</p>
<blockquote>
<p>记录名 RECORD 字段 [,字段…]</p>
</blockquote>
<p>记录名标识说明记录类型：字段表示构成记录的字段的名字、宽度和初值。每一字段的格式如下：</p>
<blockquote>
<p>字段名：宽度[&#x3D;表达式]</p>
</blockquote>
<p>字段名是记录字段的名字。宽度表示相应字段所占的位数，宽度必须是常数，宽度最大为 16 位。表达式的值将作为相应字段的初值。如果初值的数据宽度大于宽度，则汇编时将会产生错误提示信息。如果某个字段没有初值，那么缺省的初值被置为0.</p>
<p>一个记录可以含有多个字段，字段间用逗号分隔。但在一般情况下各字段的宽度之和不超过 16。例如：</p>
<blockquote>
<p>COLOR RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3</p>
</blockquote>
<p>上述记录类型 COLOR 含四个字段（BLINK、BACK、INTENSE、FORE），各字段均没有初值，他们的宽度分别是1、3、1、3。这四个字段所占总宽度正好是 8 位，所以也称为字节记录类型。这四个字段的具体意义如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196899319-290a4f74-4514-4691-81ab-1c728b32577f.png"
                      alt="8"
                ></p>
<p>BLINK（闪烁）占1各数据位，BACK（背景色）占3个数据位，INTENSE（亮度）占1个数据位，FORE（前景色）占3个数据位。</p>
<blockquote>
<p>注：在说明记录类型时，不实际分配存储单元</p>
</blockquote>
<p>如果一个记录中所有说明字段的总宽度大于 8，那么汇编程序会给对应的记录变量分配两字节，否则仅给对应的记录变量分配一字节。第一个字段放在记录左边的较高有效位，随后说明的字段放在右边后续位上，如果说明的字段总宽度不正好是8位或16位，那么向右对齐，记录高端未说明的位置为0。</p>
<p>例如：</p>
<blockquote>
<p>ABCD RECORD AA:5&#x3D;12,BB:3&#x3D;6,CC:4&#x3D;3</p>
</blockquote>
<p>上述记录类型 ABCD 含三个字段，这三个字段所占各位如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196903614-5e750d1a-7d2d-4311-8f1d-f48a7e8bb185.png"
                      alt="9"
                ></p>
<blockquote>
<p>一共是 12 位，因不满 16 位，在最高位补 4 个 0</p>
</blockquote>
<h3 id="记录变量的定义"><a href="#记录变量的定义" class="headerlink" title="记录变量的定义"></a>记录变量的定义</h3><p>定义记录变量的一般格式如下：</p>
<blockquote>
<p>[变量名] 记录名 &lt;[字段值表]&gt;</p>
</blockquote>
<ol>
<li>变量名就是当前定义的记录变量的名称，记录变量名可以省略，如果省略，那么就不能直接通过符号名访问该记录变量。</li>
<li>记录名是在说明记录类型时所用的名字。</li>
<li>字段值表用来记录变量的各字段初值，各字段值的排列顺序及大小应与记录说明时的各字段相一致，中间已逗号分隔。如果某个字段采用在说明记录时所给定的初值，那么可简单使用逗号表示；如果记录变量的所有字段均如此，那么可省去字段值表，但仍必须保留一对尖括号。</li>
</ol>
<p>例如：定义上述记录类型 COLOR，那么可定义如下结构变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARING  COLOR &lt;1,0,1,4&gt;     ;该字节值是 8CH</span><br><span class="line">        COLOR &lt;,3,,110B&gt;    ;该字节是 36H</span><br><span class="line">COLORST COLOR 32 dup(&lt;&gt;)    ;32 个字节</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果有 7 位宽时，可定义为一字符</p>
</blockquote>
<h3 id="记录专用操作符"><a href="#记录专用操作符" class="headerlink" title="记录专用操作符"></a>记录专用操作符</h3><p>操作符 WIDTH 和 MASK 仅与记录一起使用，得到已说明记录的不同方面的常数值。</p>
<p>（1）操作符 WIDTH<br>操作符 WIDTH 返回记录或记录中字段以位为单位的宽度。一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WIDTH 记录名</span><br><span class="line">或者</span><br><span class="line">WIDTH 记录字段名</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-4.asm</span><br><span class="line">;功能：记录变量操作演示</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">COLOR RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">WARING  COLOR &lt;1,2,1,4&gt;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    xor ax,ax</span><br><span class="line">    mov al,WARING</span><br><span class="line">    ;</span><br><span class="line">    sub al,WIDTH COLOR</span><br><span class="line">    mov DH,WIDTH BACK</span><br><span class="line">    ADD BH,WIDTH INTENSE</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196912147-c096a31d-da71-4182-93bc-20eb5d957cdc.png"
                      alt="10"
                ></p>
<p>（2）操作符 MASK<br>一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MASK 记录名</span><br><span class="line">或者</span><br><span class="line">MASK 记录字段</span><br></pre></td></tr></table></figure>
<p>操作符 MASK 返回一个 8 位或 16 位二进制数，指定字段各个位置为1，其余位为0。如果记录是字节记录类型，那么就是一个 8 位二进制数，如果记录类型是字记录类型，那么就是一个 16 位二进制数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-4.asm</span><br><span class="line">;功能：记录变量操作演示</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">COLOR RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3</span><br><span class="line">ABCD RECORD AA:5=12,BB:3=6,CC:4=3</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">WARING  COLOR &lt;1,2,1,4&gt;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    xor ax,ax</span><br><span class="line">    mov al,WARING</span><br><span class="line">    ;WIDTH</span><br><span class="line">    sub al,WIDTH COLOR</span><br><span class="line">    mov DH,WIDTH BACK</span><br><span class="line">    ADD BH,WIDTH INTENSE</span><br><span class="line">    ;MASK</span><br><span class="line">    mov al,MASK BLINK       ;BLINK 1位置1，其余为0</span><br><span class="line">    or al,MASK FORE         ;FORE 3位置1，其余为0</span><br><span class="line">    and dx,MASK ABCD        ;ABCD 置1</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196916229-67580622-7e8c-4b13-95df-3a1ea0028b65.png"
                      alt="11"
                ></p>
<p>（3）记录字段<br>记录字段名作为一个特殊的操作符，它不带操作数，直接返回该字段移到所在记录的最右端所需移动的位数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,BLINK</span><br><span class="line">mov cl,INTENSE</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/196960503-bb2f77b0-76d1-4e54-bef3-14684ebe8767.png"
                      alt="12"
                ></p>
<h3 id="记录及其字段的访问"><a href="#记录及其字段的访问" class="headerlink" title="记录及其字段的访问"></a>记录及其字段的访问</h3><p>由于 8086&#x2F;8088没有位操作指令，记录类型和记录操作符只能够提供访问记录中字段的便利。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-5.asm</span><br><span class="line">;功能：记录及其字段的访问</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">COLOR RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3    ;说明记录类型</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">CHAR db &#x27;A&#x27;</span><br><span class="line">ATTR COLOR &lt;0,0,1,7&gt;        ;定义记录变量</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov bp,1 shl WIDTH BACK     ;置循环计数器</span><br><span class="line">next:</span><br><span class="line">    mov ah,9                    ;在当前光标位置显示字符</span><br><span class="line">    mov bh,0</span><br><span class="line">    mov al,CHAR</span><br><span class="line">    mov bl,ATTR</span><br><span class="line">    mov cx,1</span><br><span class="line">    int 10h</span><br><span class="line">    mov al,ATTR                 ;取显示属性（记录变量）</span><br><span class="line">    mov ah,al</span><br><span class="line">    and al,not MASK BACK        ;析出除背景的其他位</span><br><span class="line">    mov cl,BACK</span><br><span class="line">    shr ah,cl                   ;把背景字段移至右端</span><br><span class="line">    inc ah                      ;调整背景色</span><br><span class="line">    shl ah,cl                   ;再向左移到原位</span><br><span class="line">    and ah,MASK BACK            ;屏蔽除背景位的其他位</span><br><span class="line">    or ah,al                    ;和其他原值合并</span><br><span class="line">    mov ATTR,ah                 ;保存属性</span><br><span class="line">    ;接收键盘输入</span><br><span class="line">    mov ah,0</span><br><span class="line">    int 16h</span><br><span class="line">    dec bp</span><br><span class="line">    jnz next</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>宏是宏汇编语言的主要特征之一。在汇编语言源程序中，若某程序片段需要多次使用，为了避免重复书写，那么可以把他定义为一条宏指令。在写源程序时，程序员用宏指令来表示程序片段；在汇编时，汇编程序用对应的程序片段代替宏指令。</p>
<h2 id="宏指令的定义和使用"><a href="#宏指令的定义和使用" class="headerlink" title="宏指令的定义和使用"></a>宏指令的定义和使用</h2><p>宏指令在使用之前要先定义。宏定义一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">宏指令 MACRO [形式参数]</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      ENDM</span><br></pre></td></tr></table></figure>

<p>其中，MACRO 和 ENDM 是一对伪指令，在宏定义中，它们必须成对出现，表示宏定义的开始和宏定义的结束。MACRO 和 ENDM 之间的内容称为宏定义体，可以是由指令、伪指令和宏指令构成的程序片段。宏指令名由用户指定，使用一般标号命名规则。可选的形式参数表可由若干个参数组成，各形式参数间用逗号分隔。</p>
<p>例如：把将 AL 寄存器内的低4位转换为对应十六进制数 ASCII 码的程序定义为一个宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTOASC AMCRO</span><br><span class="line">    AND AL,0FH</span><br><span class="line">    ADD AL,90H</span><br><span class="line">    DAA</span><br><span class="line">    ADC AL,40H</span><br><span class="line">    DAA</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>

<p>比如把 DOS 的 1 功能调用从键盘读一个字符的程序片段定义为一个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GETCH MACRO</span><br><span class="line">    MOV AH,1</span><br><span class="line">    INT 21H</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>

<p>在定义宏指令后，就可以使用宏指令来表示对应的程序片段，这称为宏调用。宏调用一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宏指令名    [实参数表]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，实参数表中的实参数应该与宏定义时的形式参数表中的形式参数相对应。</p>
</blockquote>
<p>下面的程序调用了两个刚定义的两个宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-6.asm</span><br><span class="line">;功能：演示宏汇编代码</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">HTOASC MACRO</span><br><span class="line">    AND AL,0FH</span><br><span class="line">    ADD AL,90H</span><br><span class="line">    DAA</span><br><span class="line">    ADC AL,40H</span><br><span class="line">    DAA</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">GETCH MACRO</span><br><span class="line">    MOV AH,1</span><br><span class="line">    INT 21H</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    GETCH</span><br><span class="line">    mov ah,al</span><br><span class="line">    shr al,1</span><br><span class="line">    shr al,1</span><br><span class="line">    shr al,1</span><br><span class="line">    HTOASC</span><br><span class="line">    xchg ah,al</span><br><span class="line">    HTOASC</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>对源程序汇编时，汇编程序把源程序中的宏指令替换成对应的宏定义体，这称为宏展开或宏扩展。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197006070-490eb399-088d-4707-bac8-f7b2ae6cfb1c.png"
                      alt="14"
                ></p>
<blockquote>
<p>宏汇编指令不能放在程序结尾 END START 之后。</p>
</blockquote>
<h2 id="宏指令的用途"><a href="#宏指令的用途" class="headerlink" title="宏指令的用途"></a>宏指令的用途</h2><h3 id="缩短源代码"><a href="#缩短源代码" class="headerlink" title="缩短源代码"></a>缩短源代码</h3><p>若在源程序中要多次使用到某个程序片段，那么就可以把此程序片段定义为一条宏指令。例如，把使光标另起一行的程序片段写成如下宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CRLF MACRO</span><br><span class="line">    XOR BH,BH</span><br><span class="line">    MOV AH,14</span><br><span class="line">    MOV AL,0DH</span><br><span class="line">    INT 10H</span><br><span class="line">    MOV AL,0AH</span><br><span class="line">    INT 10H</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>

<h3 id="扩充指令集"><a href="#扩充指令集" class="headerlink" title="扩充指令集"></a>扩充指令集</h3><p>CPU 的指令集是确定的，但利用宏能在汇编语言中在形式上崔指令进行扩充。扩充后的指令集是机器指令集与宏指令集的并集。这不仅能方便源程序的编写，而且便于理解源程序。<br>例如，把8个通用寄存器全部压入堆栈的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUSHA MACRO</span><br><span class="line">    PUSH AX</span><br><span class="line">    PUSH BX</span><br><span class="line">    PUSH CX</span><br><span class="line">    PUSH DX</span><br><span class="line">    PUSH SP</span><br><span class="line">    PUSH BP</span><br><span class="line">    PUSH SI</span><br><span class="line">    PUSH DI</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>

<h3 id="改变某些指令助记符的意义"><a href="#改变某些指令助记符的意义" class="headerlink" title="改变某些指令助记符的意义"></a>改变某些指令助记符的意义</h3><p>宏指令可以与指令助记符或伪操作指令名相同，在这种情况下，宏指令的优先级最高，而同名的指令或伪操作指令就失效了。利用宏指令的这一点，可以改变指令助记符的意义。<br>例如，在定义如下宏指令后，助记符 LODSB 所表示指令的意义就变化了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LODSB MACRO</span><br><span class="line">    MOV AH,[SI]</span><br><span class="line">    INC SI</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义与指令同名的宏指令后，根据编译器的不同，可能会出现警告信息。</p>
</blockquote>
<h2 id="宏指令中参数的使用"><a href="#宏指令中参数的使用" class="headerlink" title="宏指令中参数的使用"></a>宏指令中参数的使用</h2><p>宏指令可以不带参数，如上面定义的宏指令 GETCH 和 PUSHA 等。但往往带参数的宏指令更具有灵活性。</p>
<h3 id="宏指令的参数很灵活"><a href="#宏指令的参数很灵活" class="headerlink" title="宏指令的参数很灵活"></a>宏指令的参数很灵活</h3><p>（1）宏指令的参数可以是常数、寄存器和存储单元，也可以是表达式。<br>例1：在逻辑左指令 SHL 的基础上定义一条宏指令 SHLN，它能实现指定次数的左移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SHLN MACRO REG,NUM</span><br><span class="line">    PUSH CX</span><br><span class="line">    MOV CL,NUM</span><br><span class="line">    SHL REG,CL</span><br><span class="line">    POP CX</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>
<p>宏指令调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHLN BL,5</span><br><span class="line">SHLN SI,9</span><br><span class="line">SHLN AX,CL</span><br></pre></td></tr></table></figure>

<p>（2）宏指令的参数可以是操作码<br>例2：下面的宏指令 MANDM 有三个参数，第一个参数 OPR 作为操作符使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MANDM MACRO OPR,X,Y</span><br><span class="line">    MOV AX,X</span><br><span class="line">    OPR AX,Y</span><br><span class="line">    MOV X,AX</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>

<h3 id="宏调用参数个数可以与定义时不一致"><a href="#宏调用参数个数可以与定义时不一致" class="headerlink" title="宏调用参数个数可以与定义时不一致"></a>宏调用参数个数可以与定义时不一致</h3><p>一般来说，宏调用时使用的实参个数应该与宏定义时的形参一致，但汇编程序并不要求它们必须相等。</p>
<ol>
<li>若实参个数多余形参个数，那么多余的实参被忽略。</li>
<li>若实现的个数少于形参个数，那么多余的形参用 “空” 代替。</li>
<li>另外必须注意，宏展开后即实参取代形参后，所得的语句必须是有效的，否则汇编程序将会提示出错。</li>
</ol>
<p>例如，使用宏指令 <code>MANDM SUB,var1,var2,var3</code>后，多余的参数 VAR3 被忽略了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197095500-b466d465-ebc1-41e5-a373-b9c4863871b5.png"
                      alt="15"
                ></p>
<h2 id="特殊的宏运算"><a href="#特殊的宏运算" class="headerlink" title="特殊的宏运算"></a>特殊的宏运算</h2><p>为了方便宏的定义和调用，汇编程序还支持特殊的运算符，它们适用于宏的定义或调用，还适用于重复块。支持的特殊运算符如下表所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197096045-b6fd3a26-6873-4616-90a3-7b04322eb44d.png"
                      alt="16"
                ></p>
<h3 id="强迫替换运算符-“-amp-”"><a href="#强迫替换运算符-“-amp-”" class="headerlink" title="强迫替换运算符 “&amp;”"></a>强迫替换运算符 “&amp;”</h3><p>在宏定义中，若参数紧跟在其它在字符前或后，或者参数出现带引号的字符串中时，就必须使用该运算符，以区分参数。</p>
<p>例1：宏指令 jump 中，参数 CON 作为操作码的部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-8.asm</span><br><span class="line">;功能：演示 强迫替换运算符&amp; 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">JUMP MACRO CON,LAB</span><br><span class="line">    J&amp;CON LAB</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    JUMP NZ,next</span><br><span class="line">    ;</span><br><span class="line">next:</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197099102-939d1e82-6ac8-46f3-8e5c-8dd3a9d543e2.png"
                      alt="17"
                ></p>
<p>例2：下面定义的宏 MSGGEN 中，两个参数合并成标号，一个参数用在字符串中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-8-1.asm</span><br><span class="line">;功能：演示 强迫替换运算符&amp; 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">MSGGEN MACRO LAB,NUM,XYZ</span><br><span class="line">    LAB&amp;NUM db &#x27;HELLO MR.&amp;XYZ&#x27;,0DH,0AH,24H</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">MSGGEN MSG,1,TAYLOR</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ah,9</span><br><span class="line">    mov dx,offset MSG1</span><br><span class="line">    int 21h</span><br><span class="line">next:</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197100299-3095ce8d-489c-4445-9119-7bb8cafa1642.png"
                      alt="18"
                ></p>
<h3 id="字符串原样传递运算符-“-lt-gt-”"><a href="#字符串原样传递运算符-“-lt-gt-”" class="headerlink" title="字符串原样传递运算符 “&lt;&gt;”"></a>字符串原样传递运算符 “&lt;&gt;”</h3><p>字符串原样传递运算符是一对尖括号，在宏调用、重复块和条件汇编中，由它括起的内容作为一个字符串。在宏调用时，若实参包含逗号或空格等间隔符，则必须使用该运算符，以保证实参的完整性。若实参是某个有特殊意义的字符，为了使它只表示字符本身，也可以使用该运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-9.asm</span><br><span class="line">;功能：演示 字符串原样传递运算符 “&lt;&gt;” 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">DFMESS MACRO MESS</span><br><span class="line">    db &#x27;&amp;MESS&#x27;,0DH,0AH,0</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">DFMESS &lt;This is a example&gt;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197111904-08ee25df-0673-4f53-89dd-9717a88cebb5.png"
                      alt="19"
                ></p>
<h3 id="文字字符运算符-“-”"><a href="#文字字符运算符-“-”" class="headerlink" title="文字字符运算符 “!”"></a>文字字符运算符 “!”</h3><p>该运算符使其后的一个字符只作为一般字符。在宏调用时，如果实参中含有一些特殊字符，为了使这些字符作为一般字符来处理，那就必须在其前写上该字符。</p>
<p>例如：利用上述的宏 DFMESS 定义字符串 “Can not enter &gt; 99”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-10.asm</span><br><span class="line">;功能：演示 文字字符运算符 “!” 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">DFMESS MACRO MESS</span><br><span class="line">    db &#x27;&amp;MESS&#x27;,0DH,0AH,0</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">DFMESS &lt;Can not enter &gt; 99&gt;</span><br><span class="line">DFMESS &lt;Can not enter !&gt; 99&gt;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197138544-b9cbe42e-8f30-44ae-958f-9f7d6f3670df.png"
                      alt="20"
                ></p>
<h3 id="表达式运算符-“-”"><a href="#表达式运算符-“-”" class="headerlink" title="表达式运算符 “%”"></a>表达式运算符 “%”</h3><p>在宏调用时，使用该运算符能把其后表达式的结果作为实参替换，而非表达式自身。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-11.asm</span><br><span class="line">;功能：演示 表达式运算符 “%” 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">DFMESS MACRO MESS</span><br><span class="line">    db &#x27;&amp;MESS&#x27;,0DH,0AH,0</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">DFMESS %(12+3-4)</span><br><span class="line">DFMESS 12+3-4</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197141746-d9658284-7714-476f-9a3b-b5ca828076bf.png"
                      alt="21"
                ></p>
<h3 id="宏注释"><a href="#宏注释" class="headerlink" title="宏注释"></a>宏注释</h3><p>在宏定义中，如果注释以两个分号引导，那么扩展时该注释不会出现。</p>
<h2 id="宏与子程序的区别"><a href="#宏与子程序的区别" class="headerlink" title="宏与子程序的区别"></a>宏与子程序的区别</h2><p>采用宏和子程序这两种方法均能达到简化源程序的目的。但是这两者之间存在质的不同。</p>
<ol>
<li><p>宏调用是通过宏指令名进行的，在汇编时，由汇编程序把宏展开，有多次宏调用，就有相应次的宏扩展，因此并不简化目标程序；子程序调用是在程序执行期间执行 CALL 指令进行的，子程序代码只在目标程序中出现一次，所以目标程序也得到相应的简化。</p>
</li>
<li><p>宏调用时的参数由汇编程序通过实参替换形参的方式实现传递，所以参数很灵活；子程序调用时的参数需通过寄存器，堆栈或约定的内存单元传递。</p>
</li>
<li><p>宏调用是在汇编时完成，所以不需要额外的时间开销；子程序调用和子程序返回均需要时间，且涉及堆栈。</p>
</li>
</ol>
<p>总之，当程序片段不长，速度是主要矛盾时，通常采用宏只能够的方法简化源程序；当程序片段较长，额外操作所附加的时间就不明显，而节约存储空间是主要矛盾时，通常采用子程序的方法简化源程序和目标程序。</p>
<h2 id="与宏有关的伪指令"><a href="#与宏有关的伪指令" class="headerlink" title="与宏有关的伪指令"></a>与宏有关的伪指令</h2><h3 id="局部变量说明伪指令-LOCAL"><a href="#局部变量说明伪指令-LOCAL" class="headerlink" title="局部变量说明伪指令 LOCAL"></a>局部变量说明伪指令 LOCAL</h3><p>在宏定义体中可以使用标号。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTOASC MACRO</span><br><span class="line">    AND AL,0FH</span><br><span class="line">    CMP AL,9</span><br><span class="line">    JBE ISDECM</span><br><span class="line">    ADD AL,7</span><br><span class="line">ISDECM:</span><br><span class="line">    ADD AL,30H</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>
<p>如果在程序中多次调用上述宏 HTOASC，汇编时将出现重复定义错误，如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197153447-bdcbc56c-289a-486d-86c6-24a8c481c686.png"
                      alt="22"
                ></p>
<p>原因是每次展开宏 HTOASC 都得到一个标号 ISDECM。为此，汇编提供了伪指令 LOCAL，供程序员说明宏的局部标号。</p>
<p>伪指令 LOCAL 的一般格式如下：</p>
<blockquote>
<p>LOCAL 标号表</p>
</blockquote>
<p>标号表由标号构成，标号间用逗号隔开。汇编程序在每次展开宏时，总把由 LOCAL 伪指令说明的标号用唯一的符号（??0000至??FFFF）代替，从而避免标号重定义错误。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-12.asm</span><br><span class="line">;功能：演示 局部变量说明伪指令 LOCAL 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">HTOASC MACRO</span><br><span class="line">    LOCAL ISDECM</span><br><span class="line">    AND AL,0FH</span><br><span class="line">    CMP AL,9</span><br><span class="line">    JBE ISDECM</span><br><span class="line">    ADD AL,7</span><br><span class="line">ISDECM:</span><br><span class="line">    ADD AL,30H</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    xor ax,ax</span><br><span class="line">    mov al,7</span><br><span class="line">    HTOASC</span><br><span class="line">    mov al,5</span><br><span class="line">    HTOASC</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197153934-a54d1927-f11c-43bd-9585-5de195b13d0c.png"
                      alt="23"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197155849-0777c9f9-0d75-413a-a80a-684b09fa67dc.png"
                      alt="24"
                ></p>
<blockquote>
<p>必须注意，LOCAL 伪指令用在宏定义体内，而且必须是伪指令 MACRO 后的第一条语句，在 MACRO 和 LOCAL 伪指令之间不允许有注释和分号标志。</p>
</blockquote>
<h3 id="清除宏定义伪指令-PURGE"><a href="#清除宏定义伪指令-PURGE" class="headerlink" title="清除宏定义伪指令 PURGE"></a>清除宏定义伪指令 PURGE</h3><p>伪指令 PURGE 的作用是告诉汇编程序取消某些宏。取一般格式如下：</p>
<blockquote>
<p>PURGE 宏名表</p>
</blockquote>
<p>宏名表由宏名构成，宏名之间用逗号分隔。汇编程序在遇到 PURGE 伪指令后，就取消由宏名表所列出的宏定义，此后不再扩展这些宏。<br>例如：定义如下宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-13.asm</span><br><span class="line">;功能：演示 清除宏定义伪指令 PURGE 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">LODSB MACRO</span><br><span class="line">    MOV AH,[SI]</span><br><span class="line">    INC SI</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    LODSB</span><br><span class="line">    PURGE LODSB</span><br><span class="line">    LODSB</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197159727-5ac9cd46-c059-4d6e-8c4a-ab4bcfd110b7.png"
                      alt="25"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197162893-18bbef9f-15ea-4232-82b0-3cae4ea8fb8e.png"
                      alt="26"
                ></p>
<blockquote>
<p>微软的汇编器不允许这样用，因此编译之后原 LODSB 指令是没有的。</p>
</blockquote>
<h3 id="终止宏扩展伪指令-EXITM"><a href="#终止宏扩展伪指令-EXITM" class="headerlink" title="终止宏扩展伪指令 EXITM"></a>终止宏扩展伪指令 EXITM</h3><p>伪指令 EXITM 通知汇编程序结束当前宏调用的扩展。一般格式如下：</p>
<blockquote>
<p>EXITM</p>
</blockquote>
<p>当遇到 EXITM 时，汇编程序立即退出宏，在宏剩下的语句不被扩展。如果在一嵌套的宏内遇到伪指令 EXITM，则退出到外层宏。<br>伪指令 EXITM 通常与条件伪指令一起使用，以便在规定的条件跳过宏内的最后的语句。</p>
<h2 id="宏定义的嵌套"><a href="#宏定义的嵌套" class="headerlink" title="宏定义的嵌套"></a>宏定义的嵌套</h2><h3 id="宏定义体中调用宏"><a href="#宏定义体中调用宏" class="headerlink" title="宏定义体中调用宏"></a>宏定义体中调用宏</h3><p>宏汇编语言允许在宏定义体中使用宏调用，其限制条件仍是：必须先定义后调用。<br>如下宏 WHTOASC 的定义体内就调用了宏 HTOASC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-14.asm</span><br><span class="line">;功能：演示 嵌套宏 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">HTOASC MACRO</span><br><span class="line">    AND AL,0FH</span><br><span class="line">    ADD AL,90H</span><br><span class="line">    DAA</span><br><span class="line">    ADC AL,40H</span><br><span class="line">    DAA</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">WHTOASC MACRO</span><br><span class="line">    MOV AH,AL</span><br><span class="line">    SHR AL,1</span><br><span class="line">    SHR AL,1</span><br><span class="line">    SHR AL,1</span><br><span class="line">    SHR AL,1</span><br><span class="line">    HTOASC</span><br><span class="line">    XCHG AH,AL</span><br><span class="line">    HTOASC</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    MOV AX,0102H</span><br><span class="line">    WHTOASC</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="宏定义体中定义宏指令"><a href="#宏定义体中定义宏指令" class="headerlink" title="宏定义体中定义宏指令"></a>宏定义体中定义宏指令</h3><p>宏定义体中还可含有宏定义，但只有在调用外层的宏后，才能调用内层的宏。原因是只有在调用了外层的宏后，内层的宏定义才有效。</p>
<p>下面的宏 DEFMAC 含有一个宏定义，并且外层的宏参数 MACNAME 是内层的宏指令名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-14-1.asm</span><br><span class="line">;功能：演示 嵌套宏 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">DEFMAC MACRO MACNAME,OPERATOR</span><br><span class="line">    MACNAME MACRO X,Y,Z</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,X</span><br><span class="line">    OPERATOR AX,Y</span><br><span class="line">    MOV Z,AX</span><br><span class="line">    POP AX</span><br><span class="line">    ENDM</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">var1 dw 1</span><br><span class="line">var2 dw 1</span><br><span class="line">result dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    DEFMAC ADDITION,ADD</span><br><span class="line">    ADDITION var1,var2,result</span><br><span class="line">    ;</span><br><span class="line">    DEFMAC SUBTRACT,SUB</span><br><span class="line">    ;</span><br><span class="line">    DEFMAC LOGOR,OR</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197241380-ae668eb4-2a44-4f65-bb62-99813b9e97cf.png"
                      alt="27"
                ></p>
<blockquote>
<p>宏指令 DEFMAC 的参数 MACNAME 作为内部嵌套宏的指令名，从而实现 DEFMAC 执行之后同时声明了宏 ADDITION 指令。</p>
</blockquote>
<h1 id="重复汇编"><a href="#重复汇编" class="headerlink" title="重复汇编"></a>重复汇编</h1><p>有时程序中会连续地重复执行完全相同或几乎相同地一组语句时，当出现这种情况时，可考虑重复伪指令定义地重复块，以简化源程序。<br>重复块是允许建立在重复语句块的宏的一种特殊形式。它们与宏的不同之处在于它们没有被命名，并因而不能被调用。但像宏一样，它们可以有参数，且在汇编过程中参数可被变量替换；宏运算符、用伪指令 LOCAL 说明的符号等可用在重复块中；重复块总是由伪指令 ENDM 结束。</p>
<h2 id="伪指令-REPT"><a href="#伪指令-REPT" class="headerlink" title="伪指令 REPT"></a>伪指令 REPT</h2><p>伪指令 REPT 用于创建重复块，重复块的重复次数由一数值表达式给定。一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPT 表达式</span><br><span class="line">需要重复的语句组</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>

<ol>
<li>宏汇编程序会把 “需要重复的语句组” 连续地重复汇编，由表达式值决定重复此时。</li>
<li>表达式必须可求出数值常数。</li>
<li>任何有效汇编程序语句均可安排在 “需重复语句组” 中。</li>
</ol>
<p>例如：把字符 A 到 Z 的 ASCII 码填入数组 TABLE 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-15.asm</span><br><span class="line">;功能：演示 伪指令 “REPT” 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">CHAR = &#x27;A&#x27;</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">TABLE LABEL BYTE</span><br><span class="line">    REPT 26         ;重复块开始，规定重复次数</span><br><span class="line">    DB CHAR         ;需要重复的语句1</span><br><span class="line">CHAR = CHAR+1       ;需要重复的语句2</span><br><span class="line">    ENDM            ;结束块重复</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197311036-51a7ce9d-b7cd-4ae2-a9d5-63ed856b63e0.png"
                      alt="28"
                ></p>
<h2 id="伪指令-IRP"><a href="#伪指令-IRP" class="headerlink" title="伪指令 IRP"></a>伪指令 IRP</h2><p>伪指令 IRP 用于创建重复块，重复次数和每次重复时使用的实参由实参数列表决定。一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRP 形式参数,&lt;实参1，实参2,....,实参n&gt;</span><br><span class="line">重复语句块</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>

<ol>
<li>实参的个数决定了重复的次数。</li>
<li>宏汇编程序会把 “需要重复的语句组” 连续地重复汇编规定的次数，并在每次重复时一次用相应位置的实参代替 “需重复语句组” 中的形式参数。</li>
<li>实参数列表应放在一对尖括号内，若有多个实参数，则各实参数间用逗号分隔。</li>
</ol>
<p>例如：把 0~9 的平方值存入数组 QUART 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-15-1.asm</span><br><span class="line">;功能：演示 伪指令 IRP 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">;把 0~9 的平方值存入数组 QUART 中</span><br><span class="line">QUART LABEL BYTE</span><br><span class="line">    IRP x,&lt;0,1,2,3,4,5,6,7,8,9&gt;         ;重复块开始，尖括号中的参数规定重复次数</span><br><span class="line">    DB x*x          ;需要重复的语句1</span><br><span class="line">    ENDM            ;结束块重复</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197312728-3e3b7605-3975-48fd-b8a4-90bb53128c59.png"
                      alt="29"
                ></p>
<p>再如：把若干个寄存器值压入堆栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-15-1.asm</span><br><span class="line">;功能：演示 伪指令 IRP 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">;把 0~9 的平方值存入数组 QUART 中</span><br><span class="line">QUART LABEL BYTE</span><br><span class="line">    IRP x,&lt;0,1,2,3,4,5,6,7,8,9&gt;         ;重复块开始，尖括号中的参数规定重复次数</span><br><span class="line">    DB x*x          ;需要重复的语句1</span><br><span class="line">    ENDM            ;结束块重复</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;把若干个寄存器值压入堆栈</span><br><span class="line">    IRP REG,&lt;AX,BX,CX,DX&gt;</span><br><span class="line">    push REG</span><br><span class="line">    ENDM</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197313323-3a49da06-a77e-417b-a0ba-afa14bcfda75.png"
                      alt="30"
                ></p>
<h3 id="伪指令-IRPC"><a href="#伪指令-IRPC" class="headerlink" title="伪指令 IRPC"></a>伪指令 IRPC</h3><p>伪指令 IRPC 与 伪指令 IRP 相似，但实参数列表是一个字符串，一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRPC 形式参数,字符串</span><br><span class="line">需要重复的语句组</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>

<ol>
<li>字符串的长度规定了重复的次数。</li>
<li>宏汇编程序会把 “需要重复的语句组” 连续地重复汇编规定地次数，并在每次重复时一次用 “字符串” 中的一个字符作为参数代替 “需要重复语句组” 中的形式参数。</li>
<li>如果字符串含有空格、逗号等分隔符，那么字符串需要用尖括号括起来。</li>
</ol>
<p>例如：把从 2 开始的 10 个偶数存入字数组 TABLE 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-15-2.asm</span><br><span class="line">;功能：演示 伪指令 IRPC 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">;把从 2 开始的 10 个偶数存入字数组 TABLE 中</span><br><span class="line">TABLE LABEL BYTE</span><br><span class="line">    IRPC x,0123456789   ;重复块开始，字符串个数规定重复次数</span><br><span class="line">    dw (x+1)*2          ;需要重复的语句1</span><br><span class="line">    ENDM                ;结束块重复</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197315798-d640ada4-7129-48e4-a352-f847e1f9fead.png"
                      alt="31"
                ></p>
<h1 id="条件汇编"><a href="#条件汇编" class="headerlink" title="条件汇编"></a>条件汇编</h1><p>条件汇编语句提供根据某种条件决定是否汇编某段源程序的功能。<br>再源程序中使用条件汇编语句的主要目的是：<br>（1）通过在汇编前或汇编时改变某种体哦啊急啊 ，从而方便地产生不同地程序；<br>（2）增强宏定义能力，使得宏地适用范围更广<br>（3）改变汇编效率。</p>
<p>尽管条件汇编语句在形式上与高级语言中地条件语句相似，但本质上却完全不同。条件汇编语句是说明性语句，是由伪指令构成，它地功能是由编译器实现；一般高级语言的条件语句是执行语句，它的功能由目标程序实现。</p>
<h2 id="条件汇编伪指令"><a href="#条件汇编伪指令" class="headerlink" title="条件汇编伪指令"></a>条件汇编伪指令</h2><p>条件汇编语句的一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IFxxxx 条件表达式</span><br><span class="line">    语句组1</span><br><span class="line">[ELSE</span><br><span class="line">    语句组2]</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

<p>IFxxxx 是条件伪指令助记符的一般形式，其中 xxxx 表示构成条件语句助记符的其他字符。完整的条件伪指令助记符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IF   IFE   IFDEF   IF1   IF2</span><br><span class="line">IFB  IFNB  IFIDN   IFDIF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一定要在条件语句最后安排伪指令 ENDIF。</p>
</blockquote>
<p>条件汇编语句的意义为：如果条件伪指令要求的条件满足，那么就编译语句组 1，否则编译 ELSE 中的语句组 2。同时由于 “语句组1” 和 “语句组2” 可再含有条件语句，因此可以形成条件汇编语句的嵌套。一个嵌套的 ELSE 伪指令总是与最近但又没有 ELSE 的 IFxxxx 伪指令相匹配。</p>
<h3 id="伪指令-IF-和-IFE"><a href="#伪指令-IF-和-IFE" class="headerlink" title="伪指令 IF 和 IFE"></a>伪指令 IF 和 IFE</h3><p>伪指令 IF 的一般格式如下：</p>
<blockquote>
<p>IF 表达式</p>
</blockquote>
<p>如果表达式的值不等于0，条件为真。表达式不能包含向前引用，其结果应为一个常数值。</p>
<p>伪指令 IFE 的一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFE 表达式</span><br></pre></td></tr></table></figure>

<p>如果表达式的值等于 0，条件为真。表达式不能包含向前引用，其结果应为一个常数值。</p>
<p>例1：在下面的条件语句中，如果 MFLAG 值不为 0，即条件满足，那么就编译 “语句组1”，否则编译 “语句组2”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-16.asm</span><br><span class="line">;功能：演示 伪指令 IF 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">MFLAG = 0</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    if MFLAG</span><br><span class="line">    mov ah,0</span><br><span class="line">    int 16h     ;当 MFLAG 值不为 0 时，编译此语句组</span><br><span class="line">    else</span><br><span class="line">    mov ah,1</span><br><span class="line">    int 21h     ;当 MFLAG 值为 0 时，编译此语句组</span><br><span class="line">    endif</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197316993-87998a50-897d-4b3b-8b42-feb492f4ab78.png"
                      alt="32"
                ></p>
<p>例2：在下面的条件语句中，条件表达式是一个关系表达式，根据关系表达式的求值方法，如果 PORT 值为 0,则关系表达式的值为1，不为0所以条件满足。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-16-1.asm</span><br><span class="line">;功能：演示 伪指令 IF 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">PORT = 0</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    if PORT EQ 0</span><br><span class="line">    PORTADDR = 3F8H</span><br><span class="line">    IVECTN = 0BH</span><br><span class="line">    IMASKV = 11110111B</span><br><span class="line">    endif</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    mov ax,PORTADDR</span><br><span class="line">    mov bx,IVECTN</span><br><span class="line">    mov cx,IMASKV</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197327807-cba28287-aeb1-4145-986d-2ff4401d8715.png"
                      alt="34"
                ></p>
<p>例3：如下定义的宏 SHIFTL 使用了重复块和结束宏扩展伪指令 EXITM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-16-2.asm</span><br><span class="line">;功能：演示 伪指令 IF 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">SHIFT MACRO OP,N</span><br><span class="line">COUNT = 0</span><br><span class="line">    REPT N</span><br><span class="line">    SHL OP,1</span><br><span class="line">COUNT = COUNT+1</span><br><span class="line">    if COUNT GE N       ;如果 COUNT &gt;= N，就停止编译</span><br><span class="line">    EXITM</span><br><span class="line">    endif</span><br><span class="line">    ENDM</span><br><span class="line">    INC OP</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    SHIFT AX,1</span><br><span class="line">    ;</span><br><span class="line">    SHIFT BX,3</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197327345-971fbd69-78fc-4247-8754-b7253047369e.png"
                      alt="33"
                ></p>
<h3 id="伪指令-IFDEF-和-IFNDEF"><a href="#伪指令-IFDEF-和-IFNDEF" class="headerlink" title="伪指令 IFDEF 和 IFNDEF"></a>伪指令 IFDEF 和 IFNDEF</h3><p>伪指令 IFDEF 的一般格式如下：</p>
<blockquote>
<p>IFDEF 符号</p>
</blockquote>
<p>如果符号已定义或被说明成外部符号，则条件为真。</p>
<p>伪指令 IFNDEF 的一般格式如下：</p>
<blockquote>
<p>IFNDEF 符号</p>
</blockquote>
<p>如果符号未定义或未被说明成外部符号，则条件为真。</p>
<p>例如：在下面的条件语句中，如果已先定义符号 MLARGE，则条件满足，那么 AXINC 被定义为远过程，否则过程 AXINC 被定义成近过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-17.asm</span><br><span class="line">;功能：演示 伪指令 IFDEF 的使用</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">MLARGE = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    ifdef MLARGE</span><br><span class="line">AXINC PROC FAR          ;若已定义 MLARGE 则汇编此语句</span><br><span class="line">    else</span><br><span class="line">AXINC PROC NEAR         ;若未定义 MLARGE 则汇编此语句</span><br><span class="line">    endif</span><br><span class="line">    INC AX              ;不受影响</span><br><span class="line">    RET                 ;不受影响</span><br><span class="line">AXINC ENDP</span><br><span class="line">start:</span><br><span class="line">    call FAR ptr AXINC</span><br><span class="line">    ;</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197328355-c2bf24f0-4d3a-431b-bc7d-d632c625e6fc.png"
                      alt="35"
                ></p>
<blockquote>
<p>符号可以在源程序中定义，也可以在汇编命令行中定义。</p>
</blockquote>
<h3 id="伪指令-IF1-和-IF2"><a href="#伪指令-IF1-和-IF2" class="headerlink" title="伪指令 IF1 和 IF2"></a>伪指令 IF1 和 IF2</h3><p>伪指令 IF1 的格式如下：</p>
<blockquote>
<p>IF1</p>
</blockquote>
<p>若是第一趟扫描则条件为真。</p>
<p>伪指令 IF2 的格式如下：</p>
<blockquote>
<p>IF2</p>
</blockquote>
<p>若是第二趟扫描则条件为真。</p>
<h2 id="条件汇编与宏结合"><a href="#条件汇编与宏结合" class="headerlink" title="条件汇编与宏结合"></a>条件汇编与宏结合</h2><p>条件汇编与宏相结合，能大大扩大宏的使用范围。<br>例如：如下定义的宏 ADDNUM 有两个参数，在对宏调用扩展时，能根据不同的参数扩展成不同的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-18.asm</span><br><span class="line">;功能：演示 宏中使用条件汇编</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">ADDNUM MACRO REG,NUM</span><br><span class="line">    if (NUM GT 2) OR (NUM LE 0)</span><br><span class="line">    ADD REG,NUM</span><br><span class="line">    else</span><br><span class="line">    INC REG</span><br><span class="line">    if NUM EQ 2</span><br><span class="line">    INC REG</span><br><span class="line">    endif</span><br><span class="line">    endif</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    ADDNUM AX,1</span><br><span class="line">    ;</span><br><span class="line">    ADDNUM BX,3</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197328853-efae3078-1b70-4cc2-8d22-a74579a2f944.png"
                      alt="36"
                ></p>
<h2 id="条件汇编伪指令-1"><a href="#条件汇编伪指令-1" class="headerlink" title="条件汇编伪指令"></a>条件汇编伪指令</h2><h3 id="伪指令-IFB-和-IFNB"><a href="#伪指令-IFB-和-IFNB" class="headerlink" title="伪指令 IFB 和 IFNB"></a>伪指令 IFB 和 IFNB</h3><p>伪指令 IFB 和 IFBN<br>伪指令 IFB 一般用在宏定义内，格式如下：</p>
<blockquote>
<p>IFB &lt;参数&gt;</p>
</blockquote>
<p>如果在宏调用时没有使用实参来代替该形参，那么条件满足。注意，参数应该用尖括号起。</p>
<p>伪指令 IFNB 一般使用在宏定义，格式内，格式如下：</p>
<blockquote>
<p>IFNB &lt;参数&gt;</p>
</blockquote>
<p>如果在宏调用时使用实参来代替该形参，那么条件满足。注意，参数应该用尖括号括起。</p>
<p>例如：如下定义的宏 PRINT，若指定显示信息时，则显示，否则显示缺省信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-18-1.asm</span><br><span class="line">;功能：演示 宏中使用条件汇编</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">PRINT MACRO MSG</span><br><span class="line">    ifb &lt;MSG&gt;</span><br><span class="line">    MOV SI,OFFSET DEFAULTMSG    ;如果没有实参，输出 DEFAULTMSG</span><br><span class="line">    else</span><br><span class="line">    MOV SI,OFFSET MSG           ;如果有实参，输出 MSG 参数信息</span><br><span class="line">    endif</span><br><span class="line">    CALL SHOWIT</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">DEFAULTMSG db &#x27;Hello World!&#x27;,&#x27;$&#x27;</span><br><span class="line">MESS1 db &#x27;I LOVE MASM!&#x27;,&#x27;$&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    PRINT MESS1</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">;-------------------------------</span><br><span class="line">SHOWIT PROC</span><br><span class="line">    mov dx,si</span><br><span class="line">    mov ah,9</span><br><span class="line">    int 21h</span><br><span class="line">    ret</span><br><span class="line">SHOWIT ENDP</span><br><span class="line">;------</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h3 id="伪指令-IFIDN-和-IFDIF"><a href="#伪指令-IFIDN-和-IFDIF" class="headerlink" title="伪指令 IFIDN 和 IFDIF"></a>伪指令 IFIDN 和 IFDIF</h3><p>伪指令 IFIDN 一般使用在宏定义内，格式如下：</p>
<blockquote>
<p>IFIDN &lt;参数1&gt;,&lt;参数2&gt;<br>IDIDNI &lt;参数1&gt;,&lt;参数2&gt;</p>
</blockquote>
<p>如果 字符串参数1 与 字符串参数2 相等，则条件满足。参数1 或 参数2 可以是宏定义中的形参，如果是形参，会由之前相应的实参代替。字符串是按字符逐个比较的，格式一对大小写有区别，格式二忽略大小写区别。注意，参数应用尖括号括起。</p>
<p>伪指令 IFDIF 一般使用在宏定义内，格式如下：</p>
<blockquote>
<p>IFDIF &lt;参数1&gt;,&lt;参数2&gt;<br>IFDIFI &lt;参数1&gt;,&lt;参数2&gt;</p>
</blockquote>
<p>如果字符串1 与 字符串2 不等，则条件满足。其他说明同上。<br>例如：定义的宏 RDWR 的第二个参数就决定了读写方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-18-2.asm</span><br><span class="line">;功能：演示 宏中使用条件汇编</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">RDWR MACRO BUFF,RWMODE</span><br><span class="line">    LEA DX,BUFF</span><br><span class="line">    ifidni &lt;RWMODE&gt;,&lt;READ&gt;</span><br><span class="line">    CALL READIT</span><br><span class="line">    endif</span><br><span class="line">    ifidni &lt;RWMODE&gt;,&lt;WRITE&gt;</span><br><span class="line">    CALL WRITEIT</span><br><span class="line">    endif</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">BUFFER dw 0102h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    RDWR BUFFER,READ</span><br><span class="line">    ;</span><br><span class="line">    RDWR BUFFER,WRITE</span><br><span class="line">    RDWR BUFFER,READ</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">;-------------------------------</span><br><span class="line">READIT PROC</span><br><span class="line">    mov si,dx</span><br><span class="line">    add dx,word ptr [si]</span><br><span class="line">    add dx,3030h</span><br><span class="line">    xchg dh,dl</span><br><span class="line">    mov ah,2</span><br><span class="line">    int 21h</span><br><span class="line">    ;</span><br><span class="line">    xchg dh,dl</span><br><span class="line">    int 21h</span><br><span class="line">    ret</span><br><span class="line">READIT ENDP</span><br><span class="line"></span><br><span class="line">;--------------------------------</span><br><span class="line">WRITEIT PROC</span><br><span class="line">    mov si,dx</span><br><span class="line">    mov word ptr [si],0304h</span><br><span class="line">    ret</span><br><span class="line">WRITEIT ENDP</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>例如：如下定义的宏 GETCH 就有加强能力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GETCH MACRO CHAR</span><br><span class="line">    MOV AH,1</span><br><span class="line">    INT 21H</span><br><span class="line">    ifnb &lt;CHAR&gt;             ;如果有参数，执行下面的语句。</span><br><span class="line">    ifdifi &lt;CHAR&gt;,&lt;AL&gt;      ;如果有参数，就把AL的值传给形参 CHAR</span><br><span class="line">    MOV CHAR,AL</span><br><span class="line">    endif</span><br><span class="line">    endif</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>

<h1 id="源程序的结合"><a href="#源程序的结合" class="headerlink" title="源程序的结合"></a>源程序的结合</h1><p>为了方便编辑源程序和对程序进行修改或维护，汇编程序允许把源程序存放在多个文本文件中，在汇编时结合到一起，同时参加汇编。</p>
<h2 id="源程序的结合-1"><a href="#源程序的结合-1" class="headerlink" title="源程序的结合"></a>源程序的结合</h2><p>存放在若干文本文件中的源程序的结合是利用伪指令 INCLUDE 完成的。它的一般格式如下：</p>
<blockquote>
<p>INCLUDE 文件名</p>
</blockquote>
<p>伪指令 INCLUDE 表示汇编程序将指定的文本文件从本行起加入汇编，直到该文本文件的最后一行汇编完成后，继续汇编随后的语句。</p>
<ul>
<li>文件名可带有盘符和路径，采用 DOS 有关规则表示。</li>
<li>若文件名没有盘符或路径，则首先在汇编命令行参数 &#x2F;I 所指定的目录中寻找该文件，然后再到当前目录中寻找该文件。</li>
</ul>
<blockquote>
<p>对于 MASM 而言，最后还会由环境变量 INCLUDE 所指定的目录中寻找该文件。对于 TAMS 而言，若文件名没有扩展名，则默认为扩展名 ASM</p>
</blockquote>
<p>下列程序的功能是：接收一个字符串，然后按小写和大写形式重新显示字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-19.asm</span><br><span class="line">;功能：接收一个字符串，然后按小写和大写形式重新显示字符串。</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">INCLUDE DATA.ASM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    cld</span><br><span class="line">    mov dx,offset MESS1     ;显示提示信息</span><br><span class="line">    mov ah,9</span><br><span class="line">    int 21H</span><br><span class="line">    ;</span><br><span class="line">    mov ah,10               ;接收字符串</span><br><span class="line">    mov dx,offset BUFFER</span><br><span class="line">    int 21H</span><br><span class="line">    ;</span><br><span class="line">    call NEWLINE            ;另起一行</span><br><span class="line">    mov bl,BUFFER+1</span><br><span class="line">    xor bh,bh</span><br><span class="line">    mov BUFFER[BX+2],0</span><br><span class="line">    mov si,offset STRBEG</span><br><span class="line">    call STRLWR             ;转换成小写字符串</span><br><span class="line">    mov SI,offset STRBEG</span><br><span class="line">    call DISPMESS           ;显示信息</span><br><span class="line">    call NEWLINE            ;换行</span><br><span class="line">    ;</span><br><span class="line">    mov si,offset STRBEG</span><br><span class="line">    call STRUPR             ;转换成大写字符串</span><br><span class="line">    mov si,offset STRBEG</span><br><span class="line">    call DISPMESS</span><br><span class="line">    call NEWLINE</span><br><span class="line">EXIT:</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">NEWLINE PROC</span><br><span class="line">; 功能：形成回车和换行（光标移到写一行首）</span><br><span class="line">; 入口参数：无</span><br><span class="line">; 出口参数：无</span><br><span class="line">; 说    明：通过显示回车符形成回车，通过显示换行符形成换行</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">    push ax</span><br><span class="line">    push dx</span><br><span class="line">    mov dl,0dh</span><br><span class="line">    mov ah,2</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl,0ah</span><br><span class="line">    mov ah,2</span><br><span class="line">    int 21h</span><br><span class="line">    pop dx</span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line">NEWLINE endp</span><br><span class="line"></span><br><span class="line">;-------------------------------</span><br><span class="line">DISPMESS PROC</span><br><span class="line">;功能：显示以0结尾的字符串</span><br><span class="line">;入口参数：SI=字符串首地址偏移</span><br><span class="line">DISPME1:</span><br><span class="line">    LODSB</span><br><span class="line">    or al,al</span><br><span class="line">    jz DISPME2</span><br><span class="line">    mov dl,al</span><br><span class="line">    mov ah,2</span><br><span class="line">    int 21H</span><br><span class="line">    jmp DISPME1</span><br><span class="line">DISPME2:</span><br><span class="line">    ret</span><br><span class="line">DISPMESS ENDP</span><br><span class="line"></span><br><span class="line">INCLUDE  STRING.ASM         ;结合含子程序的文件 STRING.ASM</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>文本 DATA.ASM 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;文件名：DATA.ASM</span><br><span class="line">;内容：程序 T7-19.asm 的一部分</span><br><span class="line">STRLEN = 128</span><br><span class="line">DATA SEGMENT</span><br><span class="line">BUFFER DB STRLEN,0,STRLEN DUP(0)</span><br><span class="line">STRBEG = BUFFER+2</span><br><span class="line">MESS1 db &#x27;Please Enter string: &#x27;,&#x27;$&#x27;</span><br><span class="line">DATA ENDS</span><br></pre></td></tr></table></figure>

<p>文本文件 STRING.ASM 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">;文件名：STRING.ASM</span><br><span class="line">;内容：程序 T7-19.asm 的一部分</span><br><span class="line"></span><br><span class="line">STRLWR PROC</span><br><span class="line">;子程序名：STRLWR</span><br><span class="line">;功能：把字符串转换为小写</span><br><span class="line">;入口参数：SI=字符串起始地址偏移</span><br><span class="line">    jmp STRLWR2</span><br><span class="line">STRLWR1:</span><br><span class="line">    sub al,&#x27;A&#x27;</span><br><span class="line">    cmp al,&#x27;Z&#x27;-&#x27;A&#x27;</span><br><span class="line">    ja STRLWR2</span><br><span class="line">    add al,&#x27;a&#x27;</span><br><span class="line">    mov [si-01],al</span><br><span class="line">STRLWR2:</span><br><span class="line">    LODSB</span><br><span class="line">    and al,al</span><br><span class="line">    jnz STRLWR1</span><br><span class="line">    ret</span><br><span class="line">STRLWR ENDP</span><br><span class="line"></span><br><span class="line">STRUPR PROC</span><br><span class="line">;子程序名：STRUPR</span><br><span class="line">;功能：把字符串转换成大写</span><br><span class="line">;入口参数：SI-=字符串起始地址偏移</span><br><span class="line">    jmp STRUPR2</span><br><span class="line">STRUPR1:</span><br><span class="line">    sub al,&#x27;a&#x27;</span><br><span class="line">    cmp al,&#x27;z&#x27;-&#x27;a&#x27;</span><br><span class="line">    ja STRUPR2</span><br><span class="line">    add al,&#x27;A&#x27;</span><br><span class="line">    mov [si-01],al</span><br><span class="line">STRUPR2:</span><br><span class="line">    LODSB</span><br><span class="line">    and al,al</span><br><span class="line">    jnz STRUPR1</span><br><span class="line">    ret</span><br><span class="line">STRUPR ENDP</span><br></pre></td></tr></table></figure>

<h2 id="宏库的使用"><a href="#宏库的使用" class="headerlink" title="宏库的使用"></a>宏库的使用</h2><p>通常程序员会把一组有价值和经常使用的宏定义集中存放在一个文本文件中，这样的文本文件称为宏库。有了宏库之后，只要在源程序首使用伪指令 INCLUDE，就能方便地调用宏库了。</p>
<p>例如：建立宏库 DOSBIO.MAC 内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">;接受一个字符串</span><br><span class="line">GETSTR MACRO MBUFF</span><br><span class="line">    MOV DX,MBUFF</span><br><span class="line">    MOV AH,10</span><br><span class="line">    INT 21H</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">;显示一个字符串</span><br><span class="line">DISPSTR MACRO MBUFF</span><br><span class="line">    MOV DX,MBUFF</span><br><span class="line">    MOV AH,9</span><br><span class="line">    INT 21H</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">;取得一个字符</span><br><span class="line">GETCH MACRO CHAR</span><br><span class="line">    MOV AH,1</span><br><span class="line">    INT 21H</span><br><span class="line">    ifnb &lt;CHAR&gt;             ;如果有参数，执行下面的语句。</span><br><span class="line">    ifdifi &lt;CHAR&gt;,&lt;AL&gt;      ;如果有参数，就把AL的值传给形参 CHAR</span><br><span class="line">    MOV CHAR,AL</span><br><span class="line">    endif</span><br><span class="line">    endif</span><br><span class="line">    ENDM</span><br><span class="line"></span><br><span class="line">;显示一个字符</span><br><span class="line">ECHOCH MACRO CHAR</span><br><span class="line">    IFNB &lt;CHAR&gt;</span><br><span class="line">    IFDIFI &lt;CHAR&gt;,&lt;DL&gt;</span><br><span class="line">    MOV DL,CHAR</span><br><span class="line">    ENDIF</span><br><span class="line">ENDIF</span><br><span class="line">    MOV AH,2</span><br><span class="line">    INT 21H</span><br><span class="line">    ENDM</span><br></pre></td></tr></table></figure>

<p>源程序代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">;程序名：T7-19-1.asm</span><br><span class="line">;功能：演示宏库的使用</span><br><span class="line"></span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">INCLUDE DOSBIO.MAC          ;结合宏库 DOSBIO.MAC</span><br><span class="line">;</span><br><span class="line">INCLUDE DATA.ASM            ;含数据部分的文件 DATA.ASM</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;</span><br><span class="line">    cld</span><br><span class="line">    DISPSTR &lt;OFFSET MESS1&gt;      ;调用宏 DISPSTR</span><br><span class="line">    GETSTR &lt;OFFSET BUFFER&gt;      ;调用宏 GETSTR</span><br><span class="line">    call NEWLINE</span><br><span class="line">    ;</span><br><span class="line">    mov bl,BUFFER+1</span><br><span class="line">    xor bh,bh</span><br><span class="line">    mov BUFFER[BX+2],0</span><br><span class="line">    mov si,offset STRBEG</span><br><span class="line">    call STRLWR             ;转换成小写字符串</span><br><span class="line">    mov SI,offset STRBEG</span><br><span class="line">    call DISPMESS           ;显示信息</span><br><span class="line">    call NEWLINE            ;换行</span><br><span class="line">    ;</span><br><span class="line">    mov si,offset STRBEG</span><br><span class="line">    call STRUPR             ;转换成大写字符串</span><br><span class="line">    mov si,offset STRBEG</span><br><span class="line">    call DISPMESS</span><br><span class="line">    call NEWLINE</span><br><span class="line">EXIT:</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------</span><br><span class="line">NEWLINE PROC</span><br><span class="line">; 功能：形成回车和换行（光标移到写一行首）</span><br><span class="line">; 入口参数：无</span><br><span class="line">; 出口参数：无</span><br><span class="line">; 说    明：通过显示回车符形成回车，通过显示换行符形成换行</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">    push ax</span><br><span class="line">    push dx</span><br><span class="line">    mov dl,0dh</span><br><span class="line">    mov ah,2</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl,0ah</span><br><span class="line">    mov ah,2</span><br><span class="line">    int 21h</span><br><span class="line">    pop dx</span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line">NEWLINE endp</span><br><span class="line"></span><br><span class="line">;-------------------------------</span><br><span class="line">DISPMESS PROC</span><br><span class="line">;功能：显示以0结尾的字符串</span><br><span class="line">;入口参数：SI=字符串首地址偏移</span><br><span class="line">DISPME1:</span><br><span class="line">    LODSB</span><br><span class="line">    or al,al</span><br><span class="line">    jz DISPME2</span><br><span class="line">    mov dl,al</span><br><span class="line">    mov ah,2</span><br><span class="line">    int 21H</span><br><span class="line">    jmp DISPME1</span><br><span class="line">DISPME2:</span><br><span class="line">    ret</span><br><span class="line">DISPMESS ENDP</span><br><span class="line"></span><br><span class="line">INCLUDE  STRING.ASM         ;结合含子程序的文件 STRING.ASM</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/197375027-fd501a66-2091-4d6a-96e7-ca68e7f5552f.png"
                      alt="37"
                ></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：8086汇编-高级汇编语言技术</li>
        <li>本文作者：9unk</li>
        <li>创建时间：2022-10-18 21:53:00</li>
        <li>
            本文链接：https://9unkk.github.io/2022/10/18/8086-hui-bian-gao-ji-hui-bian-yu-yan-ji-zhu/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E6%B1%87%E7%BC%96/">#汇编</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/10/23/8086-hui-bian-mo-kuai-hua-cheng-xu-she-ji-ji-zhu/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">8086汇编-模块化程序设计</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/10/09/80386-hui-bian-ji-ben-gai-nian/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">80386汇编-基本概念</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">9unk</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%92%8C%E8%AE%B0%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">结构和记录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.1.</span> <span class="nav-text">结构类型的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">结构变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%AD%97%E6%AE%B5%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">1.1.3.</span> <span class="nav-text">结构变量及其字段的访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95"><span class="nav-number">1.2.</span> <span class="nav-text">记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.1.</span> <span class="nav-text">记录类型的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">记录变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%93%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">1.2.3.</span> <span class="nav-text">记录专用操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%8F%8A%E5%85%B6%E5%AD%97%E6%AE%B5%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">1.2.4.</span> <span class="nav-text">记录及其字段的访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">2.</span> <span class="nav-text">宏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">宏指令的定义和使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">2.2.</span> <span class="nav-text">宏指令的用途</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%A9%E7%9F%AD%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.1.</span> <span class="nav-text">缩短源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%85%85%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">扩充指令集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E6%9F%90%E4%BA%9B%E6%8C%87%E4%BB%A4%E5%8A%A9%E8%AE%B0%E7%AC%A6%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">改变某些指令助记符的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">宏指令中参数的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E5%BE%88%E7%81%B5%E6%B4%BB"><span class="nav-number">2.3.1.</span> <span class="nav-text">宏指令的参数很灵活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%B8%8E%E5%AE%9A%E4%B9%89%E6%97%B6%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">2.3.2.</span> <span class="nav-text">宏调用参数个数可以与定义时不一致</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AE%8F%E8%BF%90%E7%AE%97"><span class="nav-number">2.4.</span> <span class="nav-text">特殊的宏运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E8%BF%AB%E6%9B%BF%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%9C-amp-%E2%80%9D"><span class="nav-number">2.4.1.</span> <span class="nav-text">强迫替换运算符 “&amp;”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E6%A0%B7%E4%BC%A0%E9%80%92%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%9C-lt-gt-%E2%80%9D"><span class="nav-number">2.4.2.</span> <span class="nav-text">字符串原样传递运算符 “&lt;&gt;”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E5%AD%97%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%9C-%E2%80%9D"><span class="nav-number">2.4.3.</span> <span class="nav-text">文字字符运算符 “!”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%9C-%E2%80%9D"><span class="nav-number">2.4.4.</span> <span class="nav-text">表达式运算符 “%”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E6%B3%A8%E9%87%8A"><span class="nav-number">2.4.5.</span> <span class="nav-text">宏注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.5.</span> <span class="nav-text">宏与子程序的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%AE%8F%E6%9C%89%E5%85%B3%E7%9A%84%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-number">2.6.</span> <span class="nav-text">与宏有关的伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E%E4%BC%AA%E6%8C%87%E4%BB%A4-LOCAL"><span class="nav-number">2.6.1.</span> <span class="nav-text">局部变量说明伪指令 LOCAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4-PURGE"><span class="nav-number">2.6.2.</span> <span class="nav-text">清除宏定义伪指令 PURGE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E5%AE%8F%E6%89%A9%E5%B1%95%E4%BC%AA%E6%8C%87%E4%BB%A4-EXITM"><span class="nav-number">2.6.3.</span> <span class="nav-text">终止宏扩展伪指令 EXITM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="nav-number">2.7.</span> <span class="nav-text">宏定义的嵌套</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BD%93%E4%B8%AD%E8%B0%83%E7%94%A8%E5%AE%8F"><span class="nav-number">2.7.1.</span> <span class="nav-text">宏定义体中调用宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BD%93%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%AE%8F%E6%8C%87%E4%BB%A4"><span class="nav-number">2.7.2.</span> <span class="nav-text">宏定义体中定义宏指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%B1%87%E7%BC%96"><span class="nav-number">3.</span> <span class="nav-text">重复汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-REPT"><span class="nav-number">3.1.</span> <span class="nav-text">伪指令 REPT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-IRP"><span class="nav-number">3.2.</span> <span class="nav-text">伪指令 IRP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-IRPC"><span class="nav-number">3.2.1.</span> <span class="nav-text">伪指令 IRPC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B1%87%E7%BC%96"><span class="nav-number">4.</span> <span class="nav-text">条件汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-number">4.1.</span> <span class="nav-text">条件汇编伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-IF-%E5%92%8C-IFE"><span class="nav-number">4.1.1.</span> <span class="nav-text">伪指令 IF 和 IFE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-IFDEF-%E5%92%8C-IFNDEF"><span class="nav-number">4.1.2.</span> <span class="nav-text">伪指令 IFDEF 和 IFNDEF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-IF1-%E5%92%8C-IF2"><span class="nav-number">4.1.3.</span> <span class="nav-text">伪指令 IF1 和 IF2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B1%87%E7%BC%96%E4%B8%8E%E5%AE%8F%E7%BB%93%E5%90%88"><span class="nav-number">4.2.</span> <span class="nav-text">条件汇编与宏结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4-1"><span class="nav-number">4.3.</span> <span class="nav-text">条件汇编伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-IFB-%E5%92%8C-IFNB"><span class="nav-number">4.3.1.</span> <span class="nav-text">伪指令 IFB 和 IFNB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-IFIDN-%E5%92%8C-IFDIF"><span class="nav-number">4.3.2.</span> <span class="nav-text">伪指令 IFIDN 和 IFDIF</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">5.</span> <span class="nav-text">源程序的结合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E5%90%88-1"><span class="nav-number">5.1.</span> <span class="nav-text">源程序的结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">宏库的使用</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>

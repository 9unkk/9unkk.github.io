<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="咸鱼">
    <meta name="author" content="9unk">
    
    <title>
        
            80386汇编-高级过程 |
        
        9unk Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/logo.jpg","favicon":"/images/logo.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"人初做事，如鸡伏卵，不舍而生气渐充。如燕营巢，不息而结构渐牢。如滋培之木，不见其长，有时而大。如有本之泉，不舍昼夜，盈科而后进，放乎四海。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                9unk Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="page-template-container">
        
        
        <div class="page-template-content markdown-body">
            
                <h1 id="堆栈框架"><a href="#堆栈框架" class="headerlink" title="堆栈框架"></a>堆栈框架</h1><p>堆栈框架也称为活动记录，它是为传递的参数、子程序的返回地址、局部变量和保存的寄存器保留的堆栈空间。堆栈框架是按以下的步骤创建的：</p>
<ul>
<li>如果有传递的参数，则压入堆栈</li>
<li>子程序被调用，子程序的返回地址压入堆栈</li>
<li>子程序开始执行时，EBP 被压入堆栈</li>
<li>EBP 设为 ESP 的值，从这时开始，EBP 就会被作为寻址所有子程序参数的基地址指针使用</li>
<li>如果有局部变量，ESP减去一个数值，以便再堆栈上为局部变啊零保留空间</li>
<li>如果任何寄存器需要保存，则压入堆栈</li>
</ul>
<p>堆栈框架的结构受程序的内存模式以及参数传递约定影响。</p>
<h2 id="堆栈参数"><a href="#堆栈参数" class="headerlink" title="堆栈参数"></a>堆栈参数</h2><p>我们通常使用的传递参数的方式有3种：寄存器传参、使用约定存储单元传参（全局变量）、堆栈传参。另外还有一种 call 后区传参，这个不经常使用。<br>各个传参方式的优缺点：</p>
<ul>
<li>寄存器传参：传参方便且速度快；但寄存器较少，传参数量有限。</li>
<li>约定的存储单元传参：传参数量没有限制；传参速度慢，且不能保证代码的可用性，在产生中断的时候，全局变量有可能被改动</li>
<li>堆栈传参：传参数量没有限制，不会被改动；传参速度慢</li>
</ul>
<p>在8086计算机中堆栈传参就是申请一个堆栈段，也可以是DOS系统默认分配的一个64KB的堆栈空间。但是在 80386 计算机中堆栈的分配就变得复杂一些，它主要涉及到计算机的内存管理。</p>
<p>我们写程序至少有一个代码段，除了代码段还有数据段和堆栈段。到了386计算机体系里面，计算机增加了如下几个区域：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/222658006-968d742a-db44-4fd4-a088-f0306af5de1f.png"
                      alt="1"
                ></p>
<blockquote>
<p>我们在 8086 写的 .data 段，就是全局数据区。堆区是由程序员自定义的一块私有的内存区域，而栈区是一块公用的内存区域。上面划分的区块是人为划分的，这样划分就是为了让我们更容易理解。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/223983260-ead0b376-74ea-4b3b-a223-9ec4b3ea89b4.png"
                      alt="2"
                ></p>
<p>在进行子程序调用时，通常在堆栈上压入两类参数：</p>
<ul>
<li>值参数（变量和常量值）</li>
<li>引用参数（变量的地址）</li>
</ul>
<p><strong>传递值：</strong> 通过在堆栈上压入变量值的一份副本的方式传递参数，就称为传递值或简称传值。如下子程序传递两个 32 位整数：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226303577-d848c8ec-1119-4fbc-8303-21040dc3d497.png"
                      alt="4"
                ></p>
<p>下面是在 CALL 指令执行之前的堆栈示意图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226302638-f94b76c8-a454-4f89-ab2c-44a162532c0f.png"
                      alt="3"
                ></p>
<p><strong>传递引用：</strong> 传递引用的参数是一个对象的地址，如下子程序 swap：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226306691-cca8e5b7-bdac-480a-b109-6511eb5f0370.png"
                      alt="5"
                ></p>
<p>下面是调用 Swap 钱堆栈的示意图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226307625-c6b3f134-cdce-462a-96b5-f45191c14a0a.png"
                      alt="6"
                ></p>
<p><strong>传递数组：</strong> 在传递数组时高级语言堆栈参数用的是传递引用，通过传递值的方式传递大量数据完全不切实际，同时还会降低程序的执行速度并减少宝贵的堆栈空间。传递数组的方式如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226374119-8ae1add1-0b00-4f19-9f51-6e1a59dddc45.png"
                      alt="7"
                ></p>
<h3 id="堆栈参数的访问（C-x2F-C-）"><a href="#堆栈参数的访问（C-x2F-C-）" class="headerlink" title="堆栈参数的访问（C&#x2F;C++）"></a>堆栈参数的访问（C&#x2F;C++）</h3><p>在调用函数时，c&#x2F;c++ 程序使用标准的方法初始化访问参数：</p>
<ul>
<li>第一步：push ebp（保存 EBP 寄存器）；mov ebp,esp（将 EBP 指向栈顶）</li>
<li>第二步：push xxx；push xxx（……），保存多个寄存器值（这一步根据需求来，不是必要操作）</li>
<li>第三步：写入程序代码</li>
<li>第四步：pop xxx；pop xxx（与第二步操作相对应）</li>
<li>第五步：pop ebp（还原 ebp）</li>
<li>第六步：ret xxx（函数返回）</li>
</ul>
<p>以上面的 AddTwo 函数为例，其堆栈框架如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226384208-a65766fd-25d8-4ad0-9d1c-00376faa5c4c.png"
                      alt="8"
                ></p>
<p><strong>访问堆栈参数：</strong> C&#x2F;C++ 函数使用相对基址寻址方式访问堆栈参数，EBP 用作基址寄存器，偏移部分是一个常量。函数一般通过 EAX返回一个 32 位的值<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226385010-859c81a0-47c4-4f6a-acfe-4a51dd34ed47.png"
                      alt="9"
                ></p>
<h3 id="堆栈清理（堆栈平衡）"><a href="#堆栈清理（堆栈平衡）" class="headerlink" title="堆栈清理（堆栈平衡）"></a>堆栈清理（堆栈平衡）</h3><p>如下图所示，Example 函数破坏了堆栈：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226386787-684dd17f-bc5e-4cfa-95c9-a19c88cc3924.png"
                      alt="10"
                ></p>
<p>如下图所示函数返回前使用 <code>esp+(4*参数个数)</code> 使堆栈平衡，恢复正常。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226386992-33f4116b-9a47-472a-9d63-67035ed66801.png"
                      alt="11"
                ></p>
<p><strong>STDCALL 调用约定：</strong> 处理堆栈清理问题的另一种方法是使用 STDCALL 调用约定，可以在 AddTwo 过程中的 RET 指令后提供一个参数以修复 ESP 的值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226388735-fe0c030b-1f90-44a0-adea-06009a0fe4ec.png"
                      alt="12"
                ></p>
<blockquote>
<p>在8086汇编学习中写过代码，应该也熟悉另一种方法（在 ret 指令前使用 “mov ebp,esp” ）恢复 ESP 的值。</p>
</blockquote>
<h3 id="通过堆栈传递-8-位和-16-位的参数"><a href="#通过堆栈传递-8-位和-16-位的参数" class="headerlink" title="通过堆栈传递 8 位和 16 位的参数"></a>通过堆栈传递 8 位和 16 位的参数</h3><p>在保护模式下传递堆栈参数时，最好使用 32 位的操作数，虽然可以在堆栈压入 16 位的操作数，但这样会使得 ESP 无法对齐在双字边界上，由此可能会导致发生页错误故障，程序的性能也可能会降低。因此在传递 8 位或 16 位堆栈参数时，应把它扩展到 32 位再压栈。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226419050-15233eb4-d934-408c-84ba-ca8757175a6c.png"
                      alt="13"
                ></p>
<p>PUSH 指令自动把字符扩展到 32 位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push &#x27;x&#x27;</span><br><span class="line">call Uppercase</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226421345-1b5352f9-cf86-4ed1-a621-33f413462075.png"
                      alt="14"
                ></p>
<p>PUSH 指令不允许 8 位的操作数：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226424369-b9efea23-7b83-48d4-9806-4fd9812cf3d6.png"
                      alt="15"
                ></p>
<p>可使用 MOVZX 指令把字符值扩展至 EAX：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226424781-d32ca58c-f742-4341-bea4-ee2e5b2292d2.png"
                      alt="16"
                ></p>
<p><strong>16位参数的例子：</strong> 假设要向前面给出的 AddTwo 过程传递两个 16 位的整数，由于该过程期望接收 32 位参数，因此下面的代码将导致程序执行错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE Irvine32.inc</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">word1 WORD 1234h</span><br><span class="line">word2 WORD 4111h</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">    push word1</span><br><span class="line">    push word2</span><br><span class="line">    call AddTwo</span><br><span class="line">    exit</span><br><span class="line">main ENDP</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226621344-082d2e59-0a2e-433b-b1cc-15c90b0df655.png"
                      alt="17"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226622072-fb46e28f-9bf8-4af2-a816-2a284685badc.png"
                      alt="18"
                ></p>
<p>在16位参数入栈之前使用 movzx 指令进行零扩展，存入正确的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE Irvine32.inc</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">word1 WORD 1234h</span><br><span class="line">word2 WORD 4111h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    movzx eax,word1</span><br><span class="line">    push eax</span><br><span class="line">    movzx eax,word2</span><br><span class="line">    push eax</span><br><span class="line">    call AddTwo</span><br><span class="line">    exit</span><br><span class="line">main ENDP</span><br></pre></td></tr></table></figure>

<blockquote>
<p>过程的调用者必须确保传递的参数和过程期望的参数相一致。就堆栈参数而言，其大小和顺序都是非常重要的。</p>
</blockquote>
<h3 id="传递长整数参数"><a href="#传递长整数参数" class="headerlink" title="传递长整数参数"></a>传递长整数参数</h3><p>在使用堆栈过程传递长整数参数时，可以先把高位字压栈，然后再把低位字压栈，这样实际上是以小端存储把长整数压栈。下面的 WriteHex64 过程通过堆栈接收一个 64 位的整数并以十六进制显示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226641859-dbd57320-25f8-430b-84ae-dcf96cb1f40b.png"
                      alt="19"
                ></p>
<p>下面的例子在调用 WriteHex64 之前，首先把 longVal 的高半部分压栈，然后再把低半部分压栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE Irvine32.inc</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">longVal DQ 1234567800ABCDEFh</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    push DWORD PTR longVal+4</span><br><span class="line">    push DWORD PTR longVal</span><br><span class="line">    call WriteHex64</span><br><span class="line">    exit</span><br><span class="line">main ENDP</span><br></pre></td></tr></table></figure>

<p>下图展示了 WriteHex 过程在 EBP 压栈后的堆栈框架。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226647037-117f6d4b-3ba2-4df4-bd02-334d259e38b9.png"
                      alt="20"
                ></p>
<h3 id="保存和恢复寄存器"><a href="#保存和恢复寄存器" class="headerlink" title="保存和恢复寄存器"></a>保存和恢复寄存器</h3><p>子过程通常在修改寄存器之前保存其原来的值，以便在过程返回之前进行恢复。理想情况下，要保存的寄存器应在 EBP 设为 ESP 的值后、为局部变量保留空间之前压栈，这有助于避免改变堆栈参数的相对偏移。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226650521-3a34ab68-c65a-4aae-b445-e68503a52852.png"
                      alt="21"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226650718-c5370c7d-b884-424c-a844-26ca7318425b.png"
                      alt="22"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226650868-0bcbc8f1-ddce-419e-b5e3-6fbd3d9fd7e5.png"
                      alt="23"
                ></p>
<blockquote>
<p>书中的堆栈图是倒过来画的。</p>
</blockquote>
<h3 id="USES操作符对堆栈的影响"><a href="#USES操作符对堆栈的影响" class="headerlink" title="USES操作符对堆栈的影响"></a>USES操作符对堆栈的影响</h3><p>USES 操作符后写需要保存恢复的寄存器列表，对于列表中的每个寄存器，MASM 自动生成合适的 PUSH 和 POP 指令。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25861639/226655980-7bb4d4b7-094b-4f36-8fc6-1742376030a4.png"
                      alt="24"
                ></p>
<blockquote>
<p>注：函数存储返回值的寄存器不要跟在 USES 操作符后，这样会导致返回值错误。</p>
</blockquote>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在高级语言程序中，在单个过程中创建、使用和效汇的变量称为局部变量。局部变量与过程之外声明的全局变量相比有明显的优点：</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
            
        </div>
        <div class="page-template-comments">
            
        </div>
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">9unk</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="咸鱼">
    <meta name="author" content="9unk">
    
    <title>
        
            80386汇编-第一个窗口程序 |
        
        9unk Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/logo.jpg","favicon":"/images/logo.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"人初做事，如鸡伏卵，不舍而生气渐充。如燕营巢，不息而结构渐牢。如滋培之木，不见其长，有时而大。如有本之泉，不舍昼夜，盈科而后进，放乎四海。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                9unk Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">80386汇编-第一个窗口程序</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/logo.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">9unk</span>
                        
                            <span class="author-label">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2020-10-26 23:57:41</span>
        <span class="mobile">2020-10-26 23:57</span>
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>4.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>18 分钟</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="了解窗口"><a href="#了解窗口" class="headerlink" title="了解窗口"></a>了解窗口</h1><p>windows 屏幕上的一个个方块就是一个个窗口。windows 是多任务操作系统，可以同时运行多个程序，同样，各个程序在屏幕上显示不能互相干扰，而且多个程序可以看成是“同时”运行的，在后台的程序也可能随时向屏幕输出信息，着中间的跳读是由 windows 向术语自己的窗口显示信息。因此窗口被设计出来。</p>
<h2 id="窗口和程序的关系"><a href="#窗口和程序的关系" class="headerlink" title="窗口和程序的关系"></a>窗口和程序的关系</h2><p>大多数程序都是由多个窗口组成的，例如程序中的“图标”、“标题栏”、“放大”、“缩小”、“关闭”、“菜单栏”等等都是该程序（父窗口）的字窗口。当然有的文件没有窗口，例如 bat 脚本。所以说一个程序有没有窗口是自定义的。</p>
<h2 id="窗口程序是如何运行的"><a href="#窗口程序是如何运行的" class="headerlink" title="窗口程序是如何运行的"></a>窗口程序是如何运行的</h2><p>DOS 程序是顺序化的、按过程驱动的程序设计方法，这种程序由明显的开始、明显的过程、明显的结束。</p>
<p>窗口程序是事件驱动的，用户可能随时发出各种消息，如拖动边框，程序必须马上调整客户区的内容以适应新的窗口大小；窗口最小化，关闭按钮也可能随时被按下，着意味着程序要随时可以处理退出请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/10/27/xirReXq6KjGSsay.png"
                      alt="1-24.png"
                ></p>
<h3 id="编写的-FirstWindow-程序"><a href="#编写的-FirstWindow-程序" class="headerlink" title="编写的 FirstWindow 程序"></a>编写的 FirstWindow 程序</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/10/27/e4NwjMLdJiRhCUk.png"
                      alt="1-25.png"
                ></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">    .386</span><br><span class="line">    .model flat,stdcall</span><br><span class="line">    option casemap:none</span><br><span class="line"></span><br><span class="line">; include 文件定义</span><br><span class="line"></span><br><span class="line">include         windows.inc</span><br><span class="line">include         gdi32.inc</span><br><span class="line">includelib      gdi32.lib</span><br><span class="line">include         user32.inc</span><br><span class="line">includelib      user32.lib</span><br><span class="line">include         kernel32.inc</span><br><span class="line">includelib      kernel32.lib</span><br><span class="line"></span><br><span class="line">; 数据段</span><br><span class="line"></span><br><span class="line">                .data?</span><br><span class="line">hInstance       <span class="built_in">dd</span>      ?</span><br><span class="line">hWinMain        <span class="built_in">dd</span>      ?</span><br><span class="line"></span><br><span class="line">                .const</span><br><span class="line">szClassName     db       <span class="string">&#x27;MyClass&#x27;</span>,0</span><br><span class="line">szCaptionMain   db       <span class="string">&#x27;My first Window !&#x27;</span>,0</span><br><span class="line">szText          db       <span class="string">&#x27;Win32 Assembly, Simple and prowerful !&#x27;</span>,0</span><br><span class="line"></span><br><span class="line">; 代码段</span><br><span class="line"></span><br><span class="line">                .code</span><br><span class="line">; 窗口过程</span><br><span class="line"></span><br><span class="line">_ProcWinMain    proc    uses ebx edi esi,hWnd,uMsg,wParam,lParam</span><br><span class="line">                <span class="built_in">local</span>   @stPs:PAINTSTRUCT</span><br><span class="line">                <span class="built_in">local</span>   @stRect:RECT</span><br><span class="line">                <span class="built_in">local</span>   @hDc</span><br><span class="line"></span><br><span class="line">                mov     eax,uMsg</span><br><span class="line"></span><br><span class="line">                .<span class="keyword">if</span>     eax == WM_PAINT</span><br><span class="line">                        invoke BeginPaint,hWnd,addr @stPs</span><br><span class="line">                        mov    @hDc,eax</span><br><span class="line">                        invoke GetClientRect,hWnd,addr @stRect</span><br><span class="line">                        invoke DrawText,@hDc,addr szText,-1,\</span><br><span class="line">                        addr @stRect,\</span><br><span class="line">                        DT_SINGLELINE or DT_CENTER or DT_VCENTER</span><br><span class="line"></span><br><span class="line">                        invoke EndPaint,hWnd,addr @stPs</span><br><span class="line">                .elseif eax == WM_CLOSE</span><br><span class="line">                        invoke DestroyWindow,hWinMain</span><br><span class="line">                        invoke PostQuitMessage,NULL</span><br><span class="line">                .<span class="keyword">else</span></span><br><span class="line">                        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">                        ret</span><br><span class="line">                .endif</span><br><span class="line">                xor eax,eax</span><br><span class="line">                ret</span><br><span class="line">_ProcWinMain    endp</span><br><span class="line"></span><br><span class="line">_WinMain        proc</span><br><span class="line">                <span class="built_in">local</span> @stWndClass:WNDCLASSEX</span><br><span class="line">                <span class="built_in">local</span> @stMsg:MSG</span><br><span class="line"></span><br><span class="line">                invoke GetModuleHandle,NULL</span><br><span class="line">                mov    hInstance,eax</span><br><span class="line">                invoke RtlZeroMemory,addr @stWndClass,Sizeof @stWndClass</span><br><span class="line"></span><br><span class="line">; 注册窗口</span><br><span class="line">                invoke LoadCursor,0,IDC_ARROW</span><br><span class="line">                mov    @stWndClass.hCursor,eax</span><br><span class="line">                push   hInstance</span><br><span class="line">                pop    @stWndClass.hInstance</span><br><span class="line">                mov    @stWndClass.cbSize,sizeof WNDCLASSEX</span><br><span class="line">                mov    @stWndClass.style,CS_HREDRAW or CS_VREDRAW</span><br><span class="line">                mov    @stWndClass.lpfnWndProc,offset _ProcWinMain</span><br><span class="line">                mov    @stWndClass.hbrBackground,COLOR_WINDOW + 1</span><br><span class="line">                mov    @stWndClass.lpszClassName,offset szClassName</span><br><span class="line">                invoke RegisterClassEx,addr @stWndClass</span><br><span class="line"></span><br><span class="line">; 建立窗口</span><br><span class="line">                invoke CreateWindowEx,WS_EX_CLIENTEDGE,\</span><br><span class="line">                offset szClassName,offset szCaptionMain,\</span><br><span class="line">                WS_OVERLAPPEDWINDOW,\</span><br><span class="line">                100,100,600,400,\</span><br><span class="line">                NULL,NULL,hInstance,NULL</span><br><span class="line">                mov hWinMain,eax</span><br><span class="line">                invoke ShowWindow,hWinMain,SW_SHOWNORMAL</span><br><span class="line">                invoke UpdateWindow,hWinMain</span><br><span class="line"></span><br><span class="line">; 消息循环</span><br><span class="line">                .<span class="keyword">while</span> TRUE</span><br><span class="line">                       invoke GetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">                       .<span class="built_in">break</span> .<span class="keyword">if</span> eax == 0</span><br><span class="line">                       invoke TranslateMessage,addr @stMsg</span><br><span class="line">                       invoke DispatchMessage,addr @stMsg</span><br><span class="line">                .endw</span><br><span class="line">                ret</span><br><span class="line">_WinMain        endp</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">start:</span><br><span class="line">                call _WinMain</span><br><span class="line">                invoke ExitProcess,NULL</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>程序结构分析：程序的入口是 start，然后执行了 _WinMain 子程序，完成后就是程序退出函数 ExitProcess；_WinMain 子程序的 API 结构（GetModuleHandle —&gt; RtlZeroMemory —&gt; LoadCursor —&gt; RegisterClassEx —&gt; CreateWindowEx —&gt; ShowWindow —&gt; UpdateWindow）从这个 API 的名称中就能看出，这是一个窗口的建立过程（从注册窗口到显示窗口）。接下来就是由 3 个 API 组成的消息循环（GetMessage —&gt; TranslateMessage —&gt; DispatchMessage）。_WinMain 中还有一个 _ProcWinMain 子程序，这个子程序的功能就是把参数 uMsg 取出来，然后根据不同的 uMsg 执行不同的代码。</p>
<h3 id="窗口程序的运行过程"><a href="#窗口程序的运行过程" class="headerlink" title="窗口程序的运行过程"></a>窗口程序的运行过程</h3><p>在屏幕上显示一个窗口的过程一般有如下几步骤：</p>
<ol>
<li>得到应用程序的句柄（GetModuleHandle）</li>
<li>注册窗口类（RegisterClassEx）。在注册之前，要先填写 RegisterClassEx 的参数 WNDCLASSES 结构。</li>
<li>建立窗口（CreateWindowEx）</li>
<li>显示窗口（ShowWindow）</li>
<li>刷新窗口客户区（UpdateWindow）</li>
<li>进入无线的消息获取和处理循环。首先获取消息（GetMessage），消息到达，则将消息分派到回调函数处理（DispatchMessage），如果消息是 VM_QUIT，则退出循环。程序的另一半 _ProcWinMain 子程序就是处理消息的回调函数（Callback），也叫窗口过程，这个函数是由 windows 调用的而不是我们自己调用的。我们调用 DispatchMessage，而 DispatchMessage 在自己的内部回过来调用窗口过程。</li>
</ol>
<blockquote>
<p>所有的用户操作都是通过消息来传给应用程序的，如用户按键、鼠标移动、选择菜单和拖动窗口等，应用程序中由窗口过程接收消息并处理，在例子程序中就是 _ProcWinMain。所以说一个应用中几乎所有的功能代码都集中在窗口过程里。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/10/27/TiceIbCD2YORZJH.png"
                      alt="1-26.png"
                ></p>
<ol>
<li>windows 系统内有一个系统消息队列，当输入设备有所动作的时候，windows 就会产生相应的记录放在系统消息队列里。(如上图 a、b)</li>
<li>windows 为每个程序（严格来说是每个线程）维护一个消息队列，windows 检查系统消息队列里消息发生的位置，当位置位于某个程序的窗口范围内的时候，就会把这个消息派送到应用程序的队列里。（如上图 c）</li>
<li>当应用程序还没有来取消息的时候，消息就暂时保留在消息队列里，当程序中的消息循环执行到 GetMessage 的时候，控制权会转移到 GetMessage 所在的 USER32.DLL 中（箭头1），UESR32.DLL 从程序消息队列中取出消息（箭头2），然后把这条消息返回到应用程序（箭头3）</li>
<li>应用程序可以对这条信息做预处理，如可以用 TranslateMessage 把基于键盘扫描码的按键消息转换成基于 ASCII 码的键盘消息，以后也会用到 TranslateAccelerator 把键盘快捷键转换成命令消息，但这个步骤不是必须的。</li>
<li>然后应用程序使用 DispatchMessage 间接调用窗口过程处理这条信息。Dispatch 的英文含义是 “分派”，因为一个程序可能建有不止有一个窗口，不同的窗口消息必须分派给相应的窗口过程。当控制权转移到 USER32.DLL 中的 DispatchMessage 时，DispatchMessage 找出相应窗口的窗口过程，然后把消息的具体信息当作参数来调用它（箭头5），窗口过程根据消息找到对应的分支取处理，然后返回（箭头6），这时控制权限回到 DispatchMessage，最后 DispatchMessage 函数返回应用程序（箭头7）。这样一个循环就结束了，程序又开始新一轮的 GetMessage。</li>
<li>程序之间也可以护互发消息，PostMessage 是把一个消息放在其他程序的消息队列中（箭头d），目标程序收到这条消息就会把它放入该程序的消息队列取处理；而 SendMessage 则越过消息队列直接调用目标程序的窗口过程（箭头I），窗口过程返回以后才从 SendMessage 返回（II）</li>
</ol>
<blockquote>
<p>windows 在调用 RegisterClassEx 函数的时候会把窗口过程的地址告诉 windows。所以 windows 知道从哪里取回调。</p>
</blockquote>
<h1 id="分析窗口程序"><a href="#分析窗口程序" class="headerlink" title="分析窗口程序"></a>分析窗口程序</h1><h2 id="模块和句柄"><a href="#模块和句柄" class="headerlink" title="模块和句柄"></a>模块和句柄</h2><ol>
<li>模块<br>一个模块代表一个在内存中运行的 exe 文件或 dll 文件，用来代表这个文件所有的代码和资源，磁盘上的文件不是模块，装入内存后运行时就叫模块。为了区分地址空间中的不同模块，每个模块都有一个唯一的模块句柄来标识。</li>
</ol>
<p>由于很多 API 函数都要用到程序的模块句柄，为了方便程序中的各种资源，所以在程序一开始就先取得模块句柄并存放到一个全局变量中可以省去很多麻烦。在 win32 中，模块句柄在数值上程序在内存中装入的起始地址。</p>
<p>取得模块的句柄使用的 API 函数是 GetModuleHandle ，它的使用方法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke GetModuleHandle,lpModuleName</span><br></pre></td></tr></table></figure>

<p>lpModuleName 参数是一个指向含有模块名称字符串的指针，可以用这个函数取得程序地址空间中各个模块的句柄。例如想用 Use32.dll 的句柄以便使用其中包含的图标资源，那么可以如下使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">szUserDll db <span class="string">&#x27;user32.dll&#x27;</span>,0</span><br><span class="line">...</span><br><span class="line">invoke GetModuleHandle,addr azUserDll</span><br></pre></td></tr></table></figure>

<p>如果使用的参数是 NULL 调用 GetModuleHandle ，那么得到的是调用者本模块的句柄，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke GetModuleHandle,NULL</span><br><span class="line">mov hInstance,eax</span><br></pre></td></tr></table></figure>

<p>这里把取得的句柄放在 hInstance 变量中，hInstance 就是 hModule。</p>
<ol start="2">
<li>句柄<br>句柄可以理解为是一个编号，windows 会根据句柄的值去标识相应的窗口、文件、线程和模块等。</li>
</ol>
<h2 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h2><p>windows 中创建窗口需要先定义一个窗口类，然后在窗口类的基础上添加其他的属性建立窗口。对于按钮、文本输入框和选择框等，这些特殊的窗口 windows 都预先定义了相应的类。只有用户自定义的窗口才需要先定义自己的类，再建立窗口。</p>
<ol>
<li>注册窗口类<br>建立窗口类的方法是在系统中注册，注册窗口类的 API 函数是 RegisterClassEx，最后的 “Ex” 是扩展的意思，因为它是 win16 RegisterClass 的扩展。一个窗口的一些主要的属性，如：光标、图标、背景色、菜单和负责处理该窗口所属消息的函数。这些属性是定义在一个 WNDCLASSEX 结构中，然后再把结构的地址当参数一次性传递给 RegisterClassEx，WNDCLASSEX 是 WNDCLASS 结构的扩展。</li>
</ol>
<p>WNDCLASSEX 的结构定义为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/afOQ9KcFSRX4J6G.jpg"
                      alt="1-27.jpg"
                ></p>
<p>首先程序定义了一个 WNDCLASSEX 结构的变量 @stWndClass，用 RtlZeroMemory 将它填写全零（局部变量需要初始化），再填写结构的各字段，这样，没有赋值的部分保持为 0，结构各字段的含义如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/3r4RNT1YJUZCFq9.jpg"
                      alt="1-28.jpg"
                ></p>
<ul>
<li><p>hIcon——图标句柄，指定显示在窗口标题栏左上角的图标。windows 已经预定义了一些图标，同样，程序也可以使用资源文件中定义的图标，这些图标的句柄可以用 LoadIcon 函数获得。</p>
</li>
<li><p>hCursor——光标句柄，指定了鼠标在窗口中的光标形状。同样，windows 也预定义了一些光标，可以用 LocadCursor 获取它们的句柄，IDC_ARROW 是 Windows 预定义的箭头光标，如果想使用自定义的光标，也可以自己在资源文件中定义。</p>
</li>
<li><p>lpszMenuName——指定窗口上显示的默认菜单，它指向一个字符串，描述资源文件中菜单的名称，如果资源文件中菜单是用数值定义的，那么这里使用菜单资源的数值。窗口中的菜单也可以建立窗口函数 CreateWindowEx 的参数中指定。如果两个地方都没有指定，那么建立的窗口上就没有菜单。</p>
</li>
<li><p>hInstance——指定要注册的窗口类属于哪个模块，模块句柄在程序开始的地方用 GetModuleHandle 函数获得。</p>
</li>
<li><p>cbSize——指定 WNDCLASSEX 结构的长度，用 sizeof 伪操作来获取。主要是用来区分结构的版本，当以后新增了一个字段时，cbSize 就会相应增大，如果调用的时候 cbSize 还是旧的疮毒，表示运行的是基于旧的结构程序，这样可以防止使用无效的字段。</p>
</li>
<li><p>style——窗口风格。CS_HREDRAW 和 CS_VREDRAW 表示窗口的宽度或高度改变时是否重画窗口。比较重要的是 CS_DBLCLKS 风格，指定了它，windows 才会把在窗口中快速两次单机鼠标的行为翻译成双击消息 VM_LBUTTONDBLCLK 发给窗口过程。</p>
</li>
<li><p>hbrBackground——窗口客户区的背景色。前面的 hbr 表示它是一个刷子（Brush）的句柄，“刷子” 一词形象地表示了填充一个区域的着色模式。windows 预定义了一些刷子，如 BLACK_BRUSH 和 WHITE_BRUSH 等，可以用 下列语句来得到它们的句柄：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke GetStockObject, WHITE_BRUSH</span><br></pre></td></tr></table></figure>
<p>但在这里也可以使用颜色值，windows 已经预定义了一些颜色值，分别对应窗口各部分的颜色。使用颜色值得时候，windows 规定必须在颜色值上加1，所以程序中的指令是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    @stWndClass.hbrBackground,COLOR_WINDOW + 1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>szClassName——指定程序员要建立的类命名，以便以后用这个名称来引用它。</p>
</li>
<li><p>cbWndExtra 和 cbClsExtra——分别是在 windows 内部保存的窗口结构和类型结构给程序员预留的空间大小，用来存放自定义数据，单位是字节。不适用自定义数据的话，两个字段就是0 。</p>
</li>
<li><p>lpfnWndProc——最重要的参数，它指定了基于这个类建立的窗口的窗口过程地址。通过这个参数，Windows 就知道了在 DiskpatchMessage 函数中吧窗口消息发到哪里去，一个窗口过程可以为多个窗口服务，只要这些窗口是基于同一个窗口建立的。 Windows 中不同应用程序的按钮和文本框的行为都是一样的，因为他们是基于相同的 Windows 预定义类建立的，所以它们背后的窗口过程其实都是同一段代码。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/KTidIjnNOhXzE2a.jpg"
                      alt="1-29.jpg"
                ></p>
<ol start="2">
<li>创建窗口<br>接下来是在已注册的窗口类的基础上建立窗口。与注册窗口类时使用一个结构传递所有参数不同，建立窗口时所有的属性都是用单个参数的方式传递的，建立窗口的函数是 CreateWindowEx，同样，它是 Win 16 中 CreateWindow 函数的扩展，主要表现在多了一个 dwExStyle（扩展风格）参数。CreateWindowEx 函数的使用方法是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke CreateWindowEx,dwExStyle,lpClassName,lpWindowName,dwStyle,\</span><br><span class="line">       x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>lpClassName——建立窗口使用的类名字符串指针，在程序中指向 “MyClass” 字符串，表示使用 “MyClass” 类建立窗口。</p>
</li>
<li><p>lpWindowName——指向表示窗口的字符串，该名称会显示在标题栏上。如果该参数空白，则标题栏上什么都没有。</p>
</li>
<li><p>hMenu——窗口上要出现的菜单句柄。在注册窗口类的时候也定义了一个菜单，那是窗口的默认菜单，则使用窗口类中定义的菜单；如果这里指定了菜单句柄，则不管窗口类中有没有定义都将使用这里定义的菜单；两个地方都没有定义菜单，则窗口上没有菜单。另外，当监理的窗口是子窗口时（dwStyle 中指定了 WS_CHILD），这时 hMenu 参数指定的是子窗口的 ID 号。</p>
</li>
<li><p>lpParam——这是一个指针，指向一个欲传给窗口的参数，这个参数在 WM_CREATE 消息中可以被获取，一般情况下用不到这个字段。</p>
</li>
<li><p>hInstance——模块句柄，和注册窗口类时一样，指定了窗口所属的程序模块。</p>
</li>
<li><p>hWndParent——窗口所属的父窗口，对于普通的窗口（相对于子窗口），主要是用来在父窗口销毁时一同将其 “子” 窗口销毁，并不会把窗口位置限制在父窗口的客户区范围内，但如果要建立的是真正的子窗口（dwStyle 中指定了 WS_CHILD 的时候），这时窗口位置会被限制在父窗口的客户区范围内，同时窗口的坐标（x,y）也是以父窗口的左上角为基准的。</p>
</li>
<li><p>x,y——指定窗口左上角位置，单位是像素。默认时可指定为 CW_USEDFAULT，这样 windows 会自动为窗口指定最合适的位置，当建立子窗口时，位置是以父窗口的左上角为基准的，否则，以屏幕左上角为基准。</p>
</li>
<li><p>nWidth,nHeight——窗口的宽度和高度，也就是窗口的大小，同样是以像素为单位的。默认时可指定为 CW_USEDEFAULT，这样 windows 会自动为窗口指定最合适的大小。</p>
</li>
</ul>
<p>窗口的两个参数 dwStyle 和 dwExStyle 决定了窗口的外形和行为，下表列出了一些常见的 dwStyle 定义。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/Uy8YBWnawLE2lVD.jpg"
                      alt="1-30.jpg"
                > </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/JcQXl8vNWOju4Aw.jpg"
                      alt="1-31.jpg"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/pHJ6ClVxNmg9IO5.jpg"
                      alt="1-32.jpg"
                ></p>
<p>程序中建立窗口的相关代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; 建立窗口</span><br><span class="line">                invoke CreateWindowEx,WS_EX_CLIENTEDGE,\</span><br><span class="line">                offset szClassName,offset szCaptionMain,\</span><br><span class="line">                WS_OVERLAPPEDWINDOW,\</span><br><span class="line">                100,100,600,400,\</span><br><span class="line">                NULL,NULL,hInstance,NULL</span><br><span class="line">                mov hWinMain,eax</span><br><span class="line">                invoke ShowWindow,hWinMain,SW_SHOWNORMAL</span><br><span class="line">                invoke UpdateWindow,hWinMain</span><br></pre></td></tr></table></figure>

<p>建立窗口以后，eax 中传回来的是窗口句柄，要把它保存起来以备后用。这个时候，窗口虽然已经建立，但是还没有在屏幕上显示出来，要用 ShowWindow 把它显示出来，ShowWindow 也可以用在别的地方，主要用来控制窗口的显示状态（显示或隐藏），大小控制（最大化、最小化或原始大小）和是否激活（当前窗口还是背后的窗口），它用窗口句柄做第一个参数，第二个参数则是显示方式。下表给出了显示方式预定义值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/izymvfbZg4HsO8k.jpg"
                      alt="1-33.jpg"
                ></p>
<p>窗口显示以后，用 UpdateWindow 绘制客户区，他实际上就是向窗口发送了一条 WM_PAINT 消息。</p>
<p>CreateWindowEx 也可以用来建立子窗口，如按钮、文本框。下面举例说明建立一个按钮的方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/vQw2HyfOx8IzW3M.jpg"
                      alt="1-34.jpg"
                ></p>
<p>需要注意的是：风格一定要指定 WS_CHILD，建立的按钮才会在主窗口上。WS_VISIBLE 也要同时指定，否则按钮不会显示出来，hMenu 参数在这里用做表示最窗口 ID，将它设置为 1，在建立多个子窗口的时候，ID 应该有所区别。</p>
<ol start="3">
<li>消息循环</li>
</ol>
<p>消息循环的一般结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 消息循环</span><br><span class="line">                .<span class="keyword">while</span> TRUE</span><br><span class="line">                       invoke GetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">                       .<span class="built_in">break</span> .<span class="keyword">if</span> eax == 0</span><br><span class="line">                       invoke TranslateMessage,addr @stMsg</span><br><span class="line">                       invoke DispatchMessage,addr @stMsg</span><br><span class="line">                .endw</span><br></pre></td></tr></table></figure>

<p>消息循环中的几个函数要用 MSG 结构，用来消息传递：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/11/02/7CrmpojD9l5Nfzw.jpg"
                      alt="1-35.jpg"
                ></p>
<p>它的各个字段的含义是：</p>
<ul>
<li>hwnd——消息要法向的窗口句柄</li>
<li>message——消息标识符，在文件中以 WM_ 开头的预定义值（意思是 windows Message）</li>
<li>wParam——消息的参数之一</li>
<li>lParam——消息的参数之二</li>
<li>time——消息放入消息队列的时间</li>
<li>pt——这是一个 POINT 数据结构，表示消息放入消息队列时的鼠标坐标。</li>
</ul>
<p>这个结构定义了消息的所有属性，GetMessage 函数就是从消息对劣质取出这样的一条消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke GetMessage,lpMsg,hWnd,wMsgFilterMin,wMsgFilterMax</span><br></pre></td></tr></table></figure>

<p>函数的 lpMsg 指向一个 MSG 结构，函数会在这里返回取到消息，hWnd 参数指定要获取哪个窗口的消息，例子中指定为 NULL，表示获取的是所有本程序所属窗口的消息。例子中指定为 NULL，表示获取的是所有本程序所属窗口的消息，wMsgFilterMin 和 wMsgFilterMax 为 0 表示所有编号的消息。</p>
<p>GetMessage 函数从消息队列里取得消息，填写好 MSG 结构并返回，如果获取的消息是 WM_QUIT 消息，那么 eax 中的返回值是 0，否则 eax 返回非零值，所以用 <code>.break .if eax==0</code> 来检查返回值，如果消息队列中有 WM_QUIT 则退出循环。</p>
<p>TranslateMessage 将 MSG 结构传给 Windows 进行一些键盘消息的转换，当有键盘按下和放开时，windows 产生 WM_KEYDOWN 和 WM_KEYUP 或 WM_SYSKEYDOWN 和 WM_SYSKEYUP 消息，但这些消息的参数中包含的是按键的扫描码，转换成常用  ASCII 码要经过查表，很不方便。TranslateMessage 遇到键盘消息则将扫描码转换成 ASCII 码并在消息队列中插入 WM_CHAR 或 WM_SYSCHAR 消息，参数就是转换好的 ASCII 码，如此一来，要处理键盘消息的话只要处理 WM_CHAR 消息就好了。遇到非见哦按消息则 TranslateMessage 不做处理。</p>
<p>最后由 DispatchMessage 将消息发送到窗口对应的窗口过程处理。窗口过程返回后 DispatchMessage 函数才返回，然后开始新一轮的循环</p>
<ol start="4">
<li>窗口过程</li>
</ol>
<h1 id="窗口之间的通信"><a href="#窗口之间的通信" class="headerlink" title="窗口之间的通信"></a>窗口之间的通信</h1>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：80386汇编-第一个窗口程序</li>
        <li>本文作者：9unk</li>
        <li>创建时间：2020-10-26 23:57:41</li>
        <li>
            本文链接：https://9unkk.github.io/2020/10/26/80386-hui-bian-di-yi-ge-chuang-kou-cheng-xu/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E6%B1%87%E7%BC%96/">#汇编</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2020/11/03/od-diao-shi-ji-chu-pian/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">OD调试-基础篇</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/10/15/80386-hui-bian-shi-yong-masm/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">80386汇编-使用MASM</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">9unk</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E7%AA%97%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">了解窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.</span> <span class="nav-text">窗口和程序的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84"><span class="nav-number">1.2.</span> <span class="nav-text">窗口程序是如何运行的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%9A%84-FirstWindow-%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">编写的 FirstWindow 程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">窗口程序的运行过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">分析窗口程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8F%A5%E6%9F%84"><span class="nav-number">2.1.</span> <span class="nav-text">模块和句柄</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="nav-number">2.2.</span> <span class="nav-text">窗口创建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">3.</span> <span class="nav-text">窗口之间的通信</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
